<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Actor Viewer</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            min-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .file-input {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            color: white;
            width: 100%;
        }

        .button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .button:hover {
            background: #45a049;
        }

        .button.secondary {
            background: #2196F3;
        }

        .button.secondary:hover {
            background: #1976D2;
        }

        .actor-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 12px;
        }

        .actor-info h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .info-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 3px;
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
        }

        .control-row {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-row label {
            min-width: 80px;
            font-size: 12px;
        }

        .control-row input {
            flex: 1;
        }

        #canvas {
            display: block;
        }

        .generation-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .generation-panel h4 {
            margin: 0 0 10px 0;
            color: #FFA726;
        }

        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
            margin: 2px;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <h2>ðŸŽ­ Procedural Actor Viewer</h2>
            
            <div class="generation-panel">
                <h4>Quick Generate</h4>
                <div class="grid-2">
                    <select id="genderSelect">
                        <option value="random">Random Gender</option>
                        <option value="male">Male</option>
                        <option value="female">Female</option>
                        <option value="non-binary">Non-binary</option>
                    </select>
                    <select id="ageSelect">
                        <option value="random">Random Age</option>
                        <option value="child">Child</option>
                        <option value="teen">Teen</option>
                        <option value="young">Young Adult</option>
                        <option value="middle">Middle-aged</option>
                        <option value="elderly">Elderly</option>
                    </select>
                </div>
                <div class="grid-2">
                    <select id="buildSelect">
                        <option value="random">Random Build</option>
                        <option value="petite">Petite</option>
                        <option value="slender">Slender</option>
                        <option value="average">Average</option>
                        <option value="athletic">Athletic</option>
                        <option value="stocky">Stocky</option>
                        <option value="muscular">Muscular</option>
                    </select>
                    <select id="ethnicitySelect">
                        <option value="random">Random Ethnicity</option>
                        <option value="european">European</option>
                        <option value="african">African</option>
                        <option value="asian">Asian</option>
                        <option value="hispanic">Hispanic</option>
                        <option value="middle_eastern">Middle Eastern</option>
                        <option value="mixed">Mixed</option>
                    </select>
                </div>
                <button class="button" onclick="generateNewActor()">Generate New Actor</button>
                <button class="button secondary" onclick="generateRandomActor()">Random Actor</button>
            </div>
            
            <div>
                <h4>Load Actor File</h4>
                <input type="file" id="fileInput" accept=".json" class="file-input">
                <button class="button" onclick="loadFromFile()">Load Actor</button>
            </div>
            
            <div id="actorInfo" class="actor-info" style="display: none;">
                <h3>Current Actor</h3>
                <div id="actorDetails"></div>
            </div>
        </div>

        <div id="stats">
            <strong>Viewer Stats</strong><br>
            FPS: <span id="fps">--</span><br>
            Triangles: <span id="triangles">--</span><br>
            Camera: <span id="cameraPos">--</span>
        </div>

        <div id="controls">
            <div class="control-row">
                <label>Rotation:</label>
                <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-row">
                <label>Zoom:</label>
                <input type="range" id="zoom" min="1" max="10" step="0.1" value="3">
            </div>
            <div class="control-row">
                <button class="button secondary" onclick="resetCamera()">Reset View</button>
                <button class="button secondary" onclick="toggleWireframe()">Wireframe</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Three.js setup
        let scene, camera, renderer, controls;
        let currentActor = null;
        let animationId = null;
        let stats = { fps: 0, triangles: 0 };
        let wireframeMode = false;
        
        // Initialize viewer
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202020);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3);
            
            // Renderer setup
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            setupLighting();
            
            // Ground plane
            createGroundPlane();
            
            // Generate initial actor
            generateRandomActor();
            
            // Event listeners
            setupEventListeners();
            
            // Start animation loop
            animate();
            
            console.log('ðŸŽ­ Procedural Actor Viewer initialized');
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
            
            // Fill light
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);
            
            // Rim light
            const rimLight = new THREE.DirectionalLight(0x4444ff, 0.2);
            rimLight.position.set(0, 5, -10);
            scene.add(rimLight);
        }
        
        function createGroundPlane() {
            const geometry = new THREE.PlaneGeometry(20, 20);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x666666, 0x444444);
            scene.add(gridHelper);
        }
        
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // File input
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            
            // Controls
            document.getElementById('rotationSpeed').addEventListener('input', updateRotationSpeed);
            document.getElementById('zoom').addEventListener('input', updateZoom);
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const actorData = JSON.parse(e.target.result);
                    loadActor(actorData);
                } catch (error) {
                    alert('Error loading actor file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        function loadFromFile() {
            document.getElementById('fileInput').click();
        }
        
        function generateNewActor() {
            const params = {
                gender: getSelectValue('genderSelect'),
                ageGroup: getSelectValue('ageSelect'),  
                build: getSelectValue('buildSelect'),
                ethnicity: getSelectValue('ethnicitySelect')
            };
            
            // Remove 'random' values
            Object.keys(params).forEach(key => {
                if (params[key] === 'random') {
                    delete params[key];
                }
            });
            
            const actorData = generateProceduralActor(params);
            loadActor(actorData);
        }
        
        function generateRandomActor() {
            const actorData = generateProceduralActor({});
            loadActor(actorData);
        }
        
        function getSelectValue(id) {
            return document.getElementById(id).value;
        }
        
        function generateProceduralActor(params = {}) {
            // Simplified procedural generation for preview
            const defaults = {
                gender: randomChoice(['male', 'female', 'non-binary']),
                ageGroup: randomChoice(['child', 'teen', 'young', 'middle', 'elderly']),
                build: randomChoice(['petite', 'slender', 'average', 'athletic', 'stocky', 'muscular']),
                ethnicity: randomChoice(['european', 'african', 'asian', 'hispanic', 'middle_eastern', 'mixed']),
                height: 1.4 + Math.random() * 0.7,
                skinTone: randomChoice(['pale', 'fair', 'light', 'medium', 'olive', 'tan', 'brown', 'dark']),
                hairStyle: randomChoice(['bald', 'short', 'medium', 'long', 'curly']),
                hairColor: randomChoice(['black', 'brown', 'blonde', 'red', 'gray']),
                eyeColor: randomChoice(['brown', 'blue', 'green', 'hazel', 'gray']),
                clothing: randomChoice(['casual', 'formal', 'business', 'athletic'])
            };
            
            const resolvedParams = { ...defaults, ...params };
            
            return {
                id: `preview_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                generatedAt: new Date().toISOString(),
                parameters: resolvedParams,
                facial: generateFacialData(resolvedParams),
                body: generateBodyData(resolvedParams),
                clothing: generateClothingData(resolvedParams),
                metadata: {
                    version: '1.0.0',
                    generator: 'Viewer',
                    preview: true
                }
            };
        }
        
        function generateFacialData(params) {
            return {
                faceShape: randomChoice(['oval', 'round', 'square', 'heart']),
                eyeColor: params.eyeColor,
                eyeShape: randomChoice(['almond', 'round', 'hooded']),
                noseShape: randomChoice(['straight', 'roman', 'button']),
                mouthShape: randomChoice(['thin', 'medium', 'full']),
                eyeSize: 0.08 + (Math.random() - 0.5) * 0.04,
                noseWidth: 0.15 + (Math.random() - 0.5) * 0.08,
                mouthWidth: 0.12 + (Math.random() - 0.5) * 0.06
            };
        }
        
        function generateBodyData(params) {
            const buildModifiers = {
                petite: { scale: 0.85, muscle: 0.2 },
                slender: { scale: 0.95, muscle: 0.3 },
                average: { scale: 1.0, muscle: 0.5 },
                athletic: { scale: 1.05, muscle: 0.8 },
                stocky: { scale: 1.1, muscle: 0.6 },
                muscular: { scale: 1.15, muscle: 1.0 }
            };
            
            const modifier = buildModifiers[params.build] || buildModifiers.average;
            
            return {
                height: params.height,
                build: params.build,
                scale: modifier.scale,
                muscleDefinition: modifier.muscle,
                proportions: {
                    torso: 0.5 + (Math.random() - 0.5) * 0.1,
                    legs: 0.5 + (Math.random() - 0.5) * 0.1,
                    arms: 0.47 + (Math.random() - 0.5) * 0.06
                }
            };
        }
        
        function generateClothingData(params) {
            const clothingColors = {
                casual: ['#4169e1', '#000080', '#ff69b4'],
                formal: ['#000000', '#2f4f4f', '#ffffff'],
                business: ['#2f4f4f', '#000000', '#ffffff'],
                athletic: ['#32cd32', '#ff4500', '#1e90ff']
            };
            
            const colors = clothingColors[params.clothing] || clothingColors.casual;
            
            return {
                style: params.clothing,
                colors: colors,
                accessories: randomChoice(['none', 'glasses', 'hat', 'watch'])
            };
        }
        
        function loadActor(actorData) {
            console.log('Loading actor:', actorData);
            
            // Remove existing actor
            if (currentActor) {
                scene.remove(currentActor);
                disposeObject(currentActor);
            }
            
            // Create new actor
            currentActor = createActorMesh(actorData);
            scene.add(currentActor);
            
            // Update UI
            updateActorInfo(actorData);
            
            // Reset camera if needed
            resetCamera();
        }
        
        function createActorMesh(actorData) {
            const group = new THREE.Group();
            
            const params = actorData.parameters;
            const facial = actorData.facial;
            const body = actorData.body;
            const clothing = actorData.clothing;
            
            // Scale based on height and build
            const scale = (body.height || 1.75) / 1.75;
            const buildScale = body.scale || 1.0;
            
            // Create body
            const bodyMesh = createBody(params, body, scale * buildScale);
            group.add(bodyMesh);
            
            // Create head
            const headMesh = createHead(params, facial, scale);
            group.add(headMesh);
            
            // Create clothing
            const clothingMesh = createClothing(params, clothing, scale * buildScale);
            group.add(clothingMesh);
            
            // Create hair
            if (params.hairStyle !== 'bald') {
                const hairMesh = createHair(params, scale);
                group.add(hairMesh);
            }
            
            // Set metadata
            group.userData = {
                type: 'actor',
                source: 'procedural_preview',
                actorData: actorData
            };
            
            return group;
        }
        
        function createBody(params, bodyData, scale) {
            const geometry = new THREE.CylinderGeometry(0.3 * scale, 0.4 * scale, 1.6 * scale, 12);
            const material = new THREE.MeshPhongMaterial({
                color: getSkinColor(params.skinTone),
                shininess: 5
            });
            
            const body = new THREE.Mesh(geometry, material);
            body.position.y = 0.8 * scale;
            body.castShadow = true;
            body.receiveShadow = true;
            
            // Add arms
            const armGeometry = new THREE.CylinderGeometry(0.08 * scale, 0.06 * scale, 0.8 * scale, 8);
            const armMaterial = material.clone();
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4 * scale, 1.0 * scale, 0);
            leftArm.rotation.z = 0.2;
            leftArm.castShadow = true;
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4 * scale, 1.0 * scale, 0);
            rightArm.rotation.z = -0.2;
            rightArm.castShadow = true;
            
            // Add legs
            const legGeometry = new THREE.CylinderGeometry(0.12 * scale, 0.08 * scale, 1.0 * scale, 8);
            const legMaterial = material.clone();
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15 * scale, 0.0, 0);
            leftLeg.castShadow = true;
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15 * scale, 0.0, 0);
            rightLeg.castShadow = true;
            
            const bodyGroup = new THREE.Group();
            bodyGroup.add(body, leftArm, rightArm, leftLeg, rightLeg);
            
            return bodyGroup;
        }
        
        function createHead(params, facialData, scale) {
            const headSize = getHeadSize(params.ageGroup, scale);
            const geometry = new THREE.SphereGeometry(headSize, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: getSkinColor(params.skinTone),
                shininess: 5
            });
            
            const head = new THREE.Mesh(geometry, material);
            head.position.y = 1.6 * scale + headSize;
            head.castShadow = true;
            head.receiveShadow = true;
            
            const headGroup = new THREE.Group();
            headGroup.add(head);
            
            // Add eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05 * scale, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: getEyeColor(params.eyeColor) });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1 * scale, head.position.y + 0.05 * scale, headSize * 0.8);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1 * scale, head.position.y + 0.05 * scale, headSize * 0.8);
            
            headGroup.add(leftEye, rightEye);
            
            // Add nose
            const noseGeometry = new THREE.BoxGeometry(0.03 * scale, 0.06 * scale, 0.04 * scale);
            const noseMaterial = material.clone();
            
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, head.position.y - 0.02 * scale, headSize * 0.85);
            headGroup.add(nose);
            
            // Add mouth
            const mouthGeometry = new THREE.BoxGeometry(
                (facialData.mouthWidth || 0.08) * scale, 
                0.02 * scale, 
                0.01 * scale
            );
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0x8b0000 });
            
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, head.position.y - 0.1 * scale, headSize * 0.82);
            headGroup.add(mouth);
            
            return headGroup;
        }
        
        function createHair(params, scale) {
            const headSize = getHeadSize(params.ageGroup, scale);
            const geometry = new THREE.SphereGeometry(headSize * 1.1, 12, 12);
            const material = new THREE.MeshPhongMaterial({
                color: getHairColor(params.hairColor),
                shininess: 10
            });
            
            const hair = new THREE.Mesh(geometry, material);
            hair.position.y = 1.6 * scale + headSize + headSize * 0.1;
            hair.scale.y = getHairScale(params.hairStyle);
            hair.castShadow = true;
            
            return hair;
        }
        
        function createClothing(params, clothingData, scale) {
            const clothingGroup = new THREE.Group();
            
            // Shirt/Top
            const shirtGeometry = new THREE.CylinderGeometry(0.32 * scale, 0.42 * scale, 1.0 * scale, 12);
            const shirtMaterial = new THREE.MeshPhongMaterial({
                color: clothingData.colors[0] || '#4169e1',
                shininess: 8
            });
            
            const shirt = new THREE.Mesh(shirtGeometry, shirtMaterial);
            shirt.position.y = 0.8 * scale;
            shirt.castShadow = true;
            
            clothingGroup.add(shirt);
            
            // Pants (simplified)
            const pantsGeometry = new THREE.CylinderGeometry(0.3 * scale, 0.25 * scale, 1.0 * scale, 8);
            const pantsMaterial = new THREE.MeshPhongMaterial({
                color: clothingData.colors[1] || '#000080',
                shininess: 3
            });
            
            const pants = new THREE.Mesh(pantsGeometry, pantsMaterial);
            pants.position.y = 0.3 * scale;
            pants.castShadow = true;
            
            clothingGroup.add(pants);
            
            return clothingGroup;
        }
        
        // Helper functions
        function randomChoice(array) {
            return array[Math.floor(Math.random() * array.length)];
        }
        
        function getSkinColor(skinTone) {
            const tones = {
                pale: 0xffeedd,
                fair: 0xffe4c4,
                light: 0xffdbac,
                medium: 0xddbea9,
                olive: 0xcb997e,
                tan: 0xa0785a,
                brown: 0x8b5a3c,
                dark: 0x6f4e37
            };
            return tones[skinTone] || tones.medium;
        }
        
        function getEyeColor(eyeColor) {
            const colors = {
                brown: 0x8b4513,
                blue: 0x4169e1,
                green: 0x228b22,
                hazel: 0x696969,
                gray: 0x808080,
                amber: 0xffbf00
            };
            return colors[eyeColor] || colors.brown;
        }
        
        function getHairColor(hairColor) {
            const colors = {
                black: 0x000000,
                brown: 0x8b4513,
                blonde: 0xffd700,
                red: 0xcd853f,
                gray: 0x808080,
                white: 0xffffff
            };
            return colors[hairColor] || colors.brown;
        }
        
        function getHairScale(hairStyle) {
            const scales = {
                bald: 0,
                buzz: 0.3,
                short: 0.6,
                medium: 0.8,
                long: 1.2,
                curly: 1.0
            };
            return scales[hairStyle] || 0.6;
        }
        
        function getHeadSize(ageGroup, scale) {
            const sizes = {
                child: 0.3,
                teen: 0.32,
                young: 0.35,
                middle: 0.37,
                elderly: 0.36
            };
            return (sizes[ageGroup] || 0.35) * scale;
        }
        
        function updateActorInfo(actorData) {
            const infoDiv = document.getElementById('actorInfo');
            const detailsDiv = document.getElementById('actorDetails');
            
            const params = actorData.parameters;
            
            detailsDiv.innerHTML = `
                <div class="info-grid">
                    <div class="info-item"><strong>Gender:</strong> ${params.gender}</div>
                    <div class="info-item"><strong>Age:</strong> ${params.ageGroup}</div>
                    <div class="info-item"><strong>Build:</strong> ${params.build}</div>
                    <div class="info-item"><strong>Height:</strong> ${params.height?.toFixed(2)}m</div>
                    <div class="info-item"><strong>Ethnicity:</strong> ${params.ethnicity}</div>
                    <div class="info-item"><strong>Skin:</strong> ${params.skinTone}</div>
                    <div class="info-item"><strong>Hair:</strong> ${params.hairStyle}</div>
                    <div class="info-item"><strong>Eyes:</strong> ${params.eyeColor}</div>
                </div>
                <div style="margin-top: 10px; font-size: 11px; opacity: 0.7;">
                    ID: ${actorData.id}<br>
                    Generated: ${new Date(actorData.generatedAt).toLocaleString()}
                </div>
            `;
            
            infoDiv.style.display = 'block';
        }
        
        function resetCamera() {
            camera.position.set(0, 1.5, 3);
            controls.target.set(0, 1, 0);
            controls.update();
        }
        
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            
            if (currentActor) {
                currentActor.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = wireframeMode;
                    }
                });
            }
        }
        
        function updateRotationSpeed() {
            // Auto-rotation will be implemented in animate loop
        }
        
        function updateZoom() {
            const zoom = parseFloat(document.getElementById('zoom').value);
            camera.position.normalize().multiplyScalar(zoom);
            controls.update();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function disposeObject(object) {
            object.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }
        
        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Auto-rotation
            const rotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
            if (currentActor && rotationSpeed > 0) {
                currentActor.rotation.y += rotationSpeed * 0.01;
            }
            
            // Update controls
            controls.update();
            
            // Render
            renderer.render(scene, camera);
            
            // Update stats
            updateStats();
        }
        
        function updateStats() {
            // Simple FPS counter
            const now = performance.now();
            if (!this.lastFrame) this.lastFrame = now;
            const fps = 1000 / (now - this.lastFrame);
            this.lastFrame = now;
            
            // Triangle count
            let triangles = 0;
            scene.traverse((object) => {
                if (object.geometry) {
                    const geo = object.geometry;
                    if (geo.index) {
                        triangles += geo.index.count / 3;
                    } else {
                        triangles += geo.attributes.position.count / 3;
                    }
                }
            });
            
            // Update display
            document.getElementById('fps').textContent = fps.toFixed(1);
            document.getElementById('triangles').textContent = Math.round(triangles);
            document.getElementById('cameraPos').textContent = 
                `${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>