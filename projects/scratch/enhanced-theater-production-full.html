<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 35-Agent Theater Production System</title>
    
    <!-- ABC.js for music notation rendering and MIDI generation -->
    <script src="https://cdn.jsdelivr.net/npm/abcjs@7.0.4/dist/abcjs-basic-min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .header h1 {
            font-size: 3em;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        .header .port-info {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            display: inline-block;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .panel h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .controls {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn.primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        
        .btn.primary:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }
        
        .btn.success {
            background: linear-gradient(45deg, #00b894, #00a085);
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
        }
        
        .btn.success:hover {
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.6);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border-left: 4px solid #ffd700;
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .progress-section {
            margin: 20px 0;
        }
        
        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00b894, #55efc4);
            border-radius: 10px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .agent-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .agent-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            border-left: 4px solid;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        
        .agent-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }
        
        .agent-card.uninitialized { border-color: #636e72; }
        .agent-card.initializing { border-color: #74b9ff; }
        .agent-card.ready { border-color: #00b894; }
        .agent-card.active { border-color: #fdcb6e; }
        .agent-card.completing { border-color: #e17055; }
        .agent-card.complete { border-color: #6c5ce7; }
        .agent-card.error { border-color: #fd79a8; }
        
        .agent-name {
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffd700;
        }
        
        .agent-status {
            font-size: 0.8em;
            opacity: 0.9;
            text-transform: capitalize;
        }
        
        .log-panel {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
        }
        
        .log-content {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-indicator.running {
            background: #00b894;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.stopped {
            background: #636e72;
        }
        
        .status-indicator.error {
            background: #fd79a8;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .workflow-status {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .phase-list {
            display: grid;
            gap: 10px;
            margin-top: 15px;
        }
        
        .phase-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            border-left: 4px solid;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .phase-item.pending { border-color: #636e72; }
        .phase-item.active { border-color: #fdcb6e; }
        .phase-item.complete { border-color: #00b894; }
        
        .error-display {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid #ff6b6b;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #ff6b6b;
        }
        
        .success-display {
            background: rgba(0, 184, 148, 0.2);
            border: 1px solid #00b894;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #00b894;
        }
        
        .report-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #ffd700;
        }
        
        .report-content {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #00b894;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        .report-timestamp {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 10px;
            font-style: italic;
        }
        
        .deliverable-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #00b894;
        }
        
        .deliverable-header {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .deliverable-meta {
            font-size: 0.8em;
            opacity: 0.7;
            color: #74b9ff;
        }
        
        .deliverable-content {
            margin-top: 8px;
            line-height: 1.4;
            font-size: 0.9em;
        }
        
        .deliverable-type {
            background: rgba(116, 185, 255, 0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ Enhanced Theater Production System</h1>
        <div class="subtitle">36-Agent Coordination with Lifecycle Management</div>
        <div class="port-info">
            <strong>üåê Local Server Access:</strong><br>
            http://localhost:8000/enhanced-theater-production-full.html<br>
            <em>Start with: python -m http.server 8000</em>
        </div>
    </div>

    <div class="container">
        <!-- Control Panel -->
        <div class="panel">
            <h2>üé¨ Production Control</h2>
            <div class="controls">
                <button class="btn primary" id="startBtn" onclick="startProduction()">
                    üöÄ Start Enhanced Production
                </button>
                <button class="btn" id="initBtn" onclick="initializeAgents()" disabled>
                    üîß Initialize All Agents
                </button>
                <button class="btn success" id="statusBtn" onclick="showDetailedStatus()" disabled>
                    üìä Detailed System Status
                </button>
                <button class="btn" id="stopBtn" onclick="stopProduction()" disabled>
                    üõë Stop Production
                </button>
            </div>
            
            <div class="workflow-status">
                <h3>üìã Current Workflow</h3>
                <div id="workflowInfo">
                    <span class="status-indicator stopped"></span>
                    System Ready - Click Start to Begin
                </div>
                <div class="phase-list" id="phaseList">
                    <!-- Phases will be populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Metrics Panel -->
        <div class="panel">
            <h2>üìà Real-Time Metrics</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="readyCount">0</div>
                    <div class="metric-label">Agents Ready</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="activeCount">0</div>
                    <div class="metric-label">Agents Active</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="completeCount">0</div>
                    <div class="metric-label">Agents Complete</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="errorCount">0</div>
                    <div class="metric-label">Error Agents</div>
                </div>
            </div>
            
            <div class="progress-section">
                <h3>üéØ System Progress</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="overallProgress" style="width: 0%">0%</div>
                </div>
                
                <h3>üèÉ Agent Readiness</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="readinessProgress" style="width: 0%">0/35</div>
                </div>
            </div>
        </div>

        <!-- Agent Status Panel -->
        <div class="panel">
            <h2>üë• Agent Lifecycle States</h2>
            <div class="agent-grid" id="agentGrid">
                <div style="grid-column: 1 / -1; text-align: center; padding: 20px; opacity: 0.7;">
                    Initialize system to view agent states
                </div>
            </div>
        </div>

        <!-- Real-Time Reports Panel -->
        <div class="panel">
            <h2>üìä Live Summary Reports</h2>
            <div id="reportsContainer">
                <div class="report-section">
                    <h3><span class="live-indicator"></span>üìÖ Daily Summary</h3>
                    <div id="dailyReport" class="report-content">
                        <div style="text-align: center; padding: 20px; opacity: 0.7;">
                            Start production to see daily summaries
                        </div>
                    </div>
                    <div id="dailyReportTimestamp" class="report-timestamp">
                        Updates automatically during production
                    </div>
                </div>
                
                <div class="report-section" style="margin-top: 20px;">
                    <h3><span class="live-indicator"></span>üéØ Latest Milestone</h3>
                    <div id="milestoneReport" class="report-content">
                        <div style="text-align: center; padding: 20px; opacity: 0.7;">
                            No milestones achieved yet
                        </div>
                    </div>
                    <div id="milestoneReportTimestamp" class="report-timestamp">
                        Updates when milestones are achieved
                    </div>
                </div>
                
                <div class="report-section" style="margin-top: 20px;">
                    <h3><span class="live-indicator"></span>üî• Activity Highlights</h3>
                    <div id="highlightsReport" class="report-content">
                        <div style="text-align: center; padding: 20px; opacity: 0.7;">
                            No activity highlights yet
                        </div>
                    </div>
                    <div id="highlightsReportTimestamp" class="report-timestamp">
                        Updates in real-time with agent activities
                    </div>
                </div>
            </div>
        </div>

        <!-- Production Deliverables Panel -->
        <div class="panel">
            <h2>üìã Production Deliverables</h2>
            <div id="deliverablesContainer">
                <div style="text-align: center; padding: 20px; opacity: 0.7;">
                    Start production to see creative deliverables
                </div>
            </div>
        </div>

        <!-- System Information Panel -->
        <div class="panel">
            <h2>‚ÑπÔ∏è System Information</h2>
            <div id="systemInfo">
                <h3>üé≠ Enhanced Features:</h3>
                <ul style="padding-left: 20px; line-height: 1.6;">
                    <li>36 specialized theater production agents</li>
                    <li>Agent lifecycle management with state machine</li>
                    <li>Quality control with supervisor checkpoints</li>
                    <li>Iteration limits prevent infinite loops</li>
                    <li>Coordination primitives for task flow</li>
                    <li>Real-time monitoring and error recovery</li>
                    <li>üìä Summary Report Agent with daily/weekly/milestone reporting</li>
                </ul>
                
                <h3 style="margin-top: 20px;">üîÑ Agent Hierarchy:</h3>
                <div style="font-size: 0.9em; line-height: 1.4;">
                    <strong>Leadership:</strong> Executive Producer, Creative Director, Technical Director<br>
                    <strong>Creative:</strong> Playwright, Composer, Choreographer, Production Designer<br>
                    <strong>Design:</strong> Set, Costume, Lighting, Sound, Projection Designers<br>
                    <strong>Coordination:</strong> Assistant Director, Marketing, Script Editor<br>
                    <strong>Coaching:</strong> Voice, Acting, Movement, Fight Choreographers<br>
                    <strong>Technical:</strong> Audio Engineer, Video Director, Wardrobe<br>
                    <strong>Support:</strong> Publicist, Social Media Manager<br>
                    <strong>Reporting:</strong> Summary Report Agent (daily/weekly/milestone reports)
                </div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="log-panel">
            <h2>üìã System Activity Log</h2>
            <div class="log-content" id="logContent">
[SYSTEM] Enhanced Theater Production System Loaded
[INFO] 36-Agent coordination system with lifecycle management
[READY] Click "Start Enhanced Production" to begin demonstration
[PORT] Access via: http://localhost:8000/enhanced-theater-production-full.html

üé≠ SYSTEM CAPABILITIES:
‚úÖ Agent lifecycle state machine (UNINITIALIZED ‚Üí READY ‚Üí ACTIVE ‚Üí COMPLETE)
‚úÖ Quality control with AI-powered evaluation
‚úÖ Iteration limits and timeout protection
‚úÖ Supervisor checkpoints and task dependencies
‚úÖ Real-time monitoring and error recovery
‚úÖ Proper coordination primitives to prevent infinite loops
üìä Summary Report Agent for daily/weekly/milestone reporting

üöÄ Ready to demonstrate enhanced 36-agent theater production!
            </div>
        </div>
    </div>

    <script>
        // ===== EMBEDDED DEPENDENCIES =====
        
        // EventBus Implementation
        class EventBus {
            constructor() {
                this.events = {};
            }
            
            subscribe(event, callback) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(callback);
            }
            
            publish(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('EventBus callback error:', error);
                        }
                    });
                }
            }
            
            unsubscribe(event, callback) {
                if (this.events[event]) {
                    this.events[event] = this.events[event].filter(cb => cb !== callback);
                }
            }
        }

        // AgentLifecycleManager Implementation
        class AgentLifecycleManager {
            constructor() {
                this.STATES = {
                    UNINITIALIZED: 'uninitialized',
                    INITIALIZING: 'initializing', 
                    READY: 'ready',
                    ACTIVE: 'active',
                    COMPLETING: 'completing',
                    COMPLETE: 'complete',
                    ERROR: 'error'
                };
                
                this.agentStates = new Map();
                this.agentInitOrder = [];
                this.completionCriteria = new Map();
                this.timeoutHandlers = new Map();
                this.systemState = 'INITIALIZING';
                this.coordinationCallbacks = new Map();
                
                console.log('üîß Agent Lifecycle Manager: Coordination system initialized');
            }
            
            registerAgent(agentId, priority, completionCriteria = {}) {
                this.agentStates.set(agentId, {
                    state: this.STATES.UNINITIALIZED,
                    priority: priority,
                    initStartTime: null,
                    stateHistory: [],
                    iterations: 0,
                    lastActivity: new Date(),
                    metadata: {}
                });
                
                this.completionCriteria.set(agentId, {
                    maxIterations: completionCriteria.maxIterations || 10,
                    timeoutMs: completionCriteria.timeoutMs || 300000,
                    qualityThreshold: completionCriteria.qualityThreshold || 0.8,
                    customCriteria: completionCriteria.customCriteria || null
                });
                
                this.agentInitOrder = Array.from(this.agentStates.keys())
                    .sort((a, b) => {
                        const aPriority = this.agentStates.get(a).priority;
                        const bPriority = this.agentStates.get(b).priority;
                        return bPriority - aPriority;
                    });
                    
                console.log(`üé≠ Registered agent: ${agentId} (priority: ${priority})`);
            }
            
            async transitionAgentState(agentId, newState, metadata = {}) {
                const agentData = this.agentStates.get(agentId);
                if (!agentData) {
                    throw new Error(`Agent ${agentId} not registered`);
                }
                
                const oldState = agentData.state;
                
                if (!this.isValidTransition(oldState, newState)) {
                    console.warn(`‚ö†Ô∏è Invalid state transition for ${agentId}: ${oldState} ‚Üí ${newState}`);
                    return false;
                }
                
                agentData.state = newState;
                agentData.lastActivity = new Date();
                agentData.stateHistory.push({
                    fromState: oldState,
                    toState: newState,
                    timestamp: new Date(),
                    metadata: metadata
                });
                
                console.log(`üîÑ Agent ${agentId}: ${oldState} ‚Üí ${newState}`);
                
                this.checkSystemProgression();
                return true;
            }
            
            isValidTransition(fromState, toState) {
                const validTransitions = {
                    [this.STATES.UNINITIALIZED]: [this.STATES.INITIALIZING, this.STATES.ERROR],
                    [this.STATES.INITIALIZING]: [this.STATES.READY, this.STATES.ERROR],
                    [this.STATES.READY]: [this.STATES.ACTIVE, this.STATES.ERROR],
                    [this.STATES.ACTIVE]: [this.STATES.COMPLETING, this.STATES.ACTIVE, this.STATES.ERROR],
                    [this.STATES.COMPLETING]: [this.STATES.COMPLETE, this.STATES.ERROR],
                    [this.STATES.COMPLETE]: [this.STATES.COMPLETE],
                    [this.STATES.ERROR]: [this.STATES.INITIALIZING, this.STATES.ERROR]
                };
                
                return validTransitions[fromState]?.includes(toState) || false;
            }
            
            checkAgentCompletionCriteria(agentId) {
                const agentData = this.agentStates.get(agentId);
                const criteria = this.completionCriteria.get(agentId);
                
                if (!agentData || !criteria) return false;
                
                if (agentData.iterations >= criteria.maxIterations) {
                    return true;
                }
                
                const now = new Date();
                const activeTime = now - agentData.lastActivity;
                if (activeTime > criteria.timeoutMs) {
                    return true;
                }
                
                if (criteria.customCriteria && criteria.customCriteria(agentData)) {
                    return true;
                }
                
                return false;
            }
            
            getAgentsReadyForInit() {
                return this.agentInitOrder.filter(agentId => {
                    const state = this.agentStates.get(agentId)?.state;
                    return state === this.STATES.UNINITIALIZED;
                });
            }
            
            checkSystemProgression() {
                const stateCounts = this.getStateDistribution();
                
                if (stateCounts[this.STATES.READY] === this.agentStates.size) {
                    console.log('üéâ ALL AGENTS READY - System can begin production');
                    this.systemState = 'ALL_READY';
                    this.notifySystemStateChange('ALL_READY');
                }
                
                if (stateCounts[this.STATES.COMPLETE] === this.agentStates.size) {
                    console.log('üèÅ ALL AGENTS COMPLETE - Production finished');
                    this.systemState = 'PRODUCTION_COMPLETE';
                    this.notifySystemStateChange('PRODUCTION_COMPLETE');
                }
                
                if (stateCounts[this.STATES.ERROR] > 0) {
                    const errorAgents = this.getAgentsByState(this.STATES.ERROR);
                    console.warn(`üö® System has ${stateCounts[this.STATES.ERROR]} agents in error state:`, errorAgents);
                }
            }
            
            getStateDistribution() {
                const distribution = {};
                Object.values(this.STATES).forEach(state => {
                    distribution[state] = 0;
                });
                
                for (const agentData of this.agentStates.values()) {
                    distribution[agentData.state]++;
                }
                
                return distribution;
            }
            
            getAgentsByState(targetState) {
                const agents = [];
                for (const [agentId, agentData] of this.agentStates.entries()) {
                    if (agentData.state === targetState) {
                        agents.push(agentId);
                    }
                }
                return agents;
            }
            
            getSystemStatus() {
                const distribution = this.getStateDistribution();
                const totalAgents = this.agentStates.size;
                
                return {
                    systemState: this.systemState,
                    totalAgents: totalAgents,
                    stateDistribution: distribution,
                    readyAgents: this.getAgentsByState(this.STATES.READY),
                    activeAgents: this.getAgentsByState(this.STATES.ACTIVE),
                    completeAgents: this.getAgentsByState(this.STATES.COMPLETE),
                    errorAgents: this.getAgentsByState(this.STATES.ERROR),
                    progressPercent: (distribution[this.STATES.COMPLETE] / totalAgents) * 100
                };
            }
            
            onSystemStateChange(state, callback) {
                if (!this.coordinationCallbacks.has(state)) {
                    this.coordinationCallbacks.set(state, []);
                }
                this.coordinationCallbacks.get(state).push(callback);
            }
            
            notifySystemStateChange(newState) {
                const callbacks = this.coordinationCallbacks.get(newState) || [];
                callbacks.forEach(callback => {
                    try {
                        callback(newState, this.getSystemStatus());
                    } catch (error) {
                        console.error(`System state callback error:`, error);
                    }
                });
            }
            
            cleanup() {
                for (const timeoutId of this.timeoutHandlers.values()) {
                    if (typeof timeoutId === 'number') {
                        clearTimeout(timeoutId);
                    } else {
                        clearInterval(timeoutId);
                    }
                }
                this.timeoutHandlers.clear();
                console.log('üßπ Agent Lifecycle Manager: Cleanup complete');
            }
        }

        // Enhanced Production Orchestrator
        class EnhancedProductionOrchestrator {
            constructor(config = {}) {
                this.lifecycleManager = new AgentLifecycleManager();
                this.eventBus = new EventBus();
                
                // Initialize task deliverables storage for reporting
                this.taskDeliverables = {};
                
                this.qualityControls = {
                    maxIterationsPerTask: config.maxIterations || 3,
                    qualityThreshold: config.qualityThreshold || 0.85,
                    budgetPerTask: config.budgetPerTask || 500,
                    supervisorCheckpoints: true,
                    alwaysRunMinimumIterations: config.minIterations || 1
                };
                
                this.workflowTemplates = {
                    musical_theater: {
                        name: 'Professional Musical Theater Production - "Dreams of Tomorrow"',
                        estimatedDuration: '22 minutes total production time',
                        phases: [
                            { 
                                name: 'Pre-Production Planning', 
                                dependencies: [], 
                                tasks: ['concept_development', 'initial_research', 'budget_planning', 'venue_planning'],
                                duration: 180000, // 3 minutes
                                requiredAgents: ['executive-producer', 'creative-director', 'technical-director', 'production-designer']
                            },
                            { 
                                name: 'Script Development - Phase 1', 
                                dependencies: ['Pre-Production Planning'], 
                                tasks: ['story_outline', 'character_creation', 'initial_script_draft', 'dramaturgical_review'],
                                duration: 200000, // 3.3 minutes
                                requiredAgents: ['ai-playwright', 'script-editor', 'dramaturge', 'creative-director']
                            },
                            { 
                                name: 'Musical Composition - Phase 1', 
                                dependencies: ['Script Development - Phase 1'], 
                                tasks: ['thematic_composition', 'song_concepts', 'musical_structure', 'demo_recordings'],
                                duration: 180000, // 3 minutes
                                requiredAgents: ['music-composer', 'music-director', 'rehearsal-pianist']
                            },
                            { 
                                name: 'Design Conceptualization', 
                                dependencies: ['Script Development - Phase 1'], 
                                tasks: ['visual_concept', 'set_design_sketches', 'costume_concepts', 'lighting_mood_boards'],
                                duration: 160000, // 2.7 minutes
                                requiredAgents: ['set-designer', 'costume-designer', 'lighting-designer', 'projection-designer', 'makeup-artist']
                            },
                            { 
                                name: 'Script Refinement & Character Development', 
                                dependencies: ['Musical Composition - Phase 1'], 
                                tasks: ['dialogue_polish', 'character_arcs', 'scene_structure', 'script_revision_1'],
                                duration: 140000, // 2.3 minutes
                                requiredAgents: ['ai-playwright', 'script-editor', 'dramaturge', 'voice-coach', 'method-acting-coach']
                            },
                            { 
                                name: 'Advanced Musical Development', 
                                dependencies: ['Musical Composition - Phase 1'], 
                                tasks: ['full_orchestration', 'vocal_arrangements', 'choreography_integration', 'musical_revision'],
                                duration: 170000, // 2.8 minutes
                                requiredAgents: ['music-composer', 'music-director', 'choreographer', 'rehearsal-pianist']
                            },
                            { 
                                name: 'Technical Planning & Engineering', 
                                dependencies: ['Design Conceptualization'], 
                                tasks: ['technical_specifications', 'safety_protocols', 'equipment_planning', 'stage_engineering'],
                                duration: 150000, // 2.5 minutes
                                requiredAgents: ['technical-director', 'stage-manager', 'audio-engineer', 'props-master']
                            },
                            { 
                                name: 'Casting & Performance Preparation', 
                                dependencies: ['Script Refinement & Character Development'], 
                                tasks: ['casting_process', 'audition_coordination', 'role_assignment', 'initial_coaching'],
                                duration: 160000, // 2.7 minutes
                                requiredAgents: ['casting-director', 'voice-coach', 'method-acting-coach', 'movement-coach', 'understudies-coordinator']
                            },
                            { 
                                name: 'Design Finalization & Production', 
                                dependencies: ['Technical Planning & Engineering'], 
                                tasks: ['final_designs', 'construction_management', 'costume_production', 'prop_creation'],
                                duration: 140000, // 2.3 minutes
                                requiredAgents: ['set-designer', 'costume-designer', 'props-master', 'wardrobe-supervisor', 'makeup-artist']
                            },
                            { 
                                name: 'Audio & Visual Systems', 
                                dependencies: ['Advanced Musical Development', 'Technical Planning & Engineering'], 
                                tasks: ['sound_design', 'audio_programming', 'lighting_programming', 'projection_content'],
                                duration: 130000, // 2.2 minutes
                                requiredAgents: ['sound-designer', 'audio-engineer', 'lighting-designer', 'projection-designer', 'video-director']
                            },
                            { 
                                name: 'Rehearsal Coordination', 
                                dependencies: ['Casting & Performance Preparation', 'Design Finalization & Production'], 
                                tasks: ['rehearsal_scheduling', 'blocking_sessions', 'music_rehearsals', 'technical_integration'],
                                duration: 120000, // 2 minutes
                                requiredAgents: ['assistant-director', 'stage-manager', 'choreographer', 'fight-choreographer', 'dialect-coach']
                            },
                            { 
                                name: 'Marketing & Audience Development', 
                                dependencies: ['Casting & Performance Preparation'], 
                                tasks: ['marketing_strategy', 'promotional_content', 'community_outreach', 'press_relations'],
                                duration: 140000, // 2.3 minutes
                                requiredAgents: ['marketing-director', 'audience-development', 'publicist', 'social-media-manager', 'house-manager']
                            },
                            { 
                                name: 'Final Production & Performance', 
                                dependencies: ['Rehearsal Coordination', 'Audio & Visual Systems', 'Marketing & Audience Development'], 
                                tasks: ['dress_rehearsals', 'final_technical', 'performance_execution', 'production_documentation'],
                                duration: 120000, // 2 minutes
                                requiredAgents: ['executive-producer', 'creative-director', 'stage-manager', 'video-director', 'house-manager']
                            }
                        ]
                    }
                };
                
                this.currentProduction = null;
                this.allAgentsReady = false;
                this.productionRunning = false;
                
                this.registerAllAgentsWithLifecycle();
                
                console.log('üé≠ Enhanced Production Orchestrator: 36-agent system ready');
            }
            
            registerAllAgentsWithLifecycle() {
                const agentDefinitions = [
                    // Leadership tier (Priority 90-100)
                    { id: 'executive-producer', priority: 100, maxIterations: 5, timeoutMs: 600000 },
                    { id: 'creative-director', priority: 95, maxIterations: 5, timeoutMs: 600000 },
                    { id: 'technical-director', priority: 90, maxIterations: 5, timeoutMs: 600000 },
                    
                    // Primary creative tier (Priority 80-89)
                    { id: 'ai-playwright', priority: 85, maxIterations: 4, timeoutMs: 480000 },
                    { id: 'music-composer', priority: 85, maxIterations: 4, timeoutMs: 480000 },
                    { id: 'choreographer', priority: 85, maxIterations: 4, timeoutMs: 480000 },
                    { id: 'production-designer', priority: 85, maxIterations: 4, timeoutMs: 480000 },
                    { id: 'music-director', priority: 82, maxIterations: 4, timeoutMs: 420000 },
                    { id: 'stage-manager', priority: 80, maxIterations: 4, timeoutMs: 420000 },
                    
                    // Creative design tier (Priority 70-79)
                    { id: 'set-designer', priority: 78, maxIterations: 3, timeoutMs: 360000 },
                    { id: 'costume-designer', priority: 78, maxIterations: 3, timeoutMs: 360000 },
                    { id: 'lighting-designer', priority: 78, maxIterations: 3, timeoutMs: 360000 },
                    { id: 'sound-designer', priority: 78, maxIterations: 3, timeoutMs: 360000 },
                    { id: 'projection-designer', priority: 75, maxIterations: 3, timeoutMs: 360000 },
                    { id: 'makeup-artist', priority: 75, maxIterations: 3, timeoutMs: 360000 },
                    { id: 'props-master', priority: 75, maxIterations: 3, timeoutMs: 360000 },
                    { id: 'casting-director', priority: 75, maxIterations: 3, timeoutMs: 360000 },
                    
                    // Coordination tier (Priority 60-69)
                    { id: 'assistant-director', priority: 68, maxIterations: 3, timeoutMs: 300000 },
                    { id: 'dramaturge', priority: 65, maxIterations: 3, timeoutMs: 300000 },
                    { id: 'script-editor', priority: 65, maxIterations: 3, timeoutMs: 300000 },
                    { id: 'marketing-director', priority: 65, maxIterations: 3, timeoutMs: 300000 },
                    { id: 'audience-development', priority: 62, maxIterations: 3, timeoutMs: 300000 },
                    { id: 'house-manager', priority: 60, maxIterations: 3, timeoutMs: 300000 },
                    
                    // Specialized coaching tier (Priority 50-59)
                    { id: 'voice-coach', priority: 58, maxIterations: 2, timeoutMs: 240000 },
                    { id: 'method-acting-coach', priority: 58, maxIterations: 2, timeoutMs: 240000 },
                    { id: 'movement-coach', priority: 55, maxIterations: 2, timeoutMs: 240000 },
                    { id: 'fight-choreographer', priority: 55, maxIterations: 2, timeoutMs: 240000 },
                    { id: 'dialect-coach', priority: 52, maxIterations: 2, timeoutMs: 240000 },
                    { id: 'understudies-coordinator', priority: 50, maxIterations: 2, timeoutMs: 240000 },
                    
                    // Technical execution tier (Priority 40-49)
                    { id: 'audio-engineer', priority: 48, maxIterations: 2, timeoutMs: 180000 },
                    { id: 'video-director', priority: 48, maxIterations: 2, timeoutMs: 180000 },
                    { id: 'rehearsal-pianist', priority: 45, maxIterations: 2, timeoutMs: 180000 },
                    { id: 'wardrobe-supervisor', priority: 42, maxIterations: 2, timeoutMs: 180000 },
                    
                    // Support tier (Priority 30-39)
                    { id: 'publicist', priority: 35, maxIterations: 2, timeoutMs: 180000 },
                    { id: 'social-media-manager', priority: 32, maxIterations: 2, timeoutMs: 180000 },
                    
                    // Reporting tier (Priority 70)
                    { id: 'summary-report', priority: 70, maxIterations: 1000, timeoutMs: 3600000, isMonitor: true }
                ];
                
                for (const agentDef of agentDefinitions) {
                    this.lifecycleManager.registerAgent(agentDef.id, agentDef.priority, {
                        maxIterations: agentDef.maxIterations,
                        timeoutMs: agentDef.timeoutMs,
                        qualityThreshold: 0.8,
                        customCriteria: (agentData) => {
                            if (agentData.iterations >= agentDef.maxIterations) return true;
                            if (agentData.metadata.deliverables?.length >= 2) return true;
                            return false;
                        }
                    });
                }
                
                this.lifecycleManager.onSystemStateChange('ALL_READY', (state, status) => {
                    console.log('üéâ All agents ready - production can begin');
                    this.onAllAgentsReady(status);
                });
                
                this.lifecycleManager.onSystemStateChange('PRODUCTION_COMPLETE', (state, status) => {
                    console.log('üèÅ Production complete - all agents finished');
                    this.onProductionComplete(status);
                });
                
                console.log(`‚úÖ Registered ${agentDefinitions.length} agents with lifecycle management`);
            }
            
            async initializeAllAgents() {
                console.log('üöÄ Initializing all agents to READY state...');
                
                const readyAgents = this.lifecycleManager.getAgentsReadyForInit();
                
                for (const agentId of readyAgents) {
                    try {
                        await this.lifecycleManager.transitionAgentState(agentId, 'initializing');
                        await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
                        
                        // Monitor agents (summary-report) go to ready first, then active
                        if (agentId === 'summary-report') {
                            console.log(`üîÑ Transitioning ${agentId} to ready, then active as monitor`);
                            await this.lifecycleManager.transitionAgentState(agentId, 'ready', {
                                initialized: new Date(),
                                isMonitor: true
                            });
                            // Then immediately transition to active for monitoring
                            await this.lifecycleManager.transitionAgentState(agentId, 'active', {
                                isMonitor: true,
                                monitoredTasks: []
                            });
                            console.log(`‚úÖ ${agentId} successfully transitioned to active monitor state`);
                        } else {
                            await this.lifecycleManager.transitionAgentState(agentId, 'ready', {
                                initialized: new Date()
                            });
                        }
                    } catch (error) {
                        console.error(`‚ùå Failed to initialize agent ${agentId}: ${error.message}`);
                        await this.lifecycleManager.transitionAgentState(agentId, 'error', {
                            error: error.message,
                            phase: 'initialization'
                        });
                    }
                }
                
                this.lifecycleManager.checkSystemProgression();
            }
            
            async createProduction(production) {
                this.currentProduction = production;
                console.log(`üé≠ Creating production: ${production.title}`);
                
                await this.initializeAllAgents();
                await this.waitForAllAgentsReady();
                
                console.log('‚úÖ All agents ready - starting workflow execution');
                await this.executeWorkflow(production);
            }
            
            async waitForAllAgentsReady() {
                const maxWaitTime = 30000;
                const checkInterval = 500;
                let waitTime = 0;
                
                while (!this.allAgentsReady && waitTime < maxWaitTime) {
                    await new Promise(resolve => setTimeout(resolve, checkInterval));
                    waitTime += checkInterval;
                    
                    const status = this.lifecycleManager.getSystemStatus();
                    // Count agents that are ready OR active (for monitor agents like summary-report)
                    const readyOrActiveCount = status.readyAgents.length + status.activeAgents.length;
                    
                    console.log(`‚è≥ Waiting for agents: ${readyOrActiveCount}/${status.totalAgents} ready/active`);
                    
                    if (readyOrActiveCount === status.totalAgents) {
                        this.allAgentsReady = true;
                        console.log('‚úÖ All agents ready or active - proceeding with production');
                        break;
                    }
                }
                
                if (!this.allAgentsReady) {
                    const status = this.lifecycleManager.getSystemStatus();
                    console.error(`‚ùå Timeout: ${status.readyAgents.length + status.activeAgents.length}/${status.totalAgents} agents ready/active`);
                    throw new Error(`Timeout waiting for all agents to be ready. Only ${status.readyAgents.length + status.activeAgents.length}/${status.totalAgents} agents ready/active`);
                }
            }
            
            async executeWorkflow(production) {
                console.log('üöÄ Starting Professional Musical Theater Production');
                console.log(`üìã Production: ${production.title}`);
                this.productionRunning = true;
                
                const workflow = this.workflowTemplates.musical_theater;
                const phaseResults = {};
                const phasePromises = new Map();
                const completedPhases = new Set();
                
                // Create shared state for inter-agent communication
                this.productionState = {
                    script: { versions: [], currentVersion: null },
                    music: { compositions: [], arrangements: [] },
                    designs: { set: [], costume: [], lighting: [] },
                    casting: { roles: [], auditions: [] },
                    technical: { plans: [], systems: [] },
                    marketing: { campaigns: [], materials: [] }
                };
                
                console.log(`üé≠ Executing ${workflow.phases.length} production phases with dependency management`);
                
                // Execute phases with proper dependency management
                await this.executePhasesDependencyManaged(workflow.phases, completedPhases, phaseResults, phasePromises);
                
                console.log('üéâ PRODUCTION COMPLETE: "Dreams of Tomorrow"');
                console.log(`üìä Phases Completed: ${Object.keys(phaseResults).length}`);
                console.log(`üë• All 36 agents utilized across production workflow`);
                
                // Now mark all agents as complete since production is finished
                await this.completeAllAgents();
                
                this.productionRunning = false;
                
                return phaseResults;
            }

            async completeAllAgents() {
                console.log('üèÅ Completing all agents after production finish...');
                
                const activeAgents = this.lifecycleManager.getAgentsByState('active');
                console.log(`üìã Transitioning ${activeAgents.length} active agents to complete state`);
                
                for (const agentId of activeAgents) {
                    try {
                        // Skip summary-report as it's a monitor agent
                        if (agentId === 'summary-report') continue;
                        
                        const agentData = this.lifecycleManager.agentStates.get(agentId);
                        const completedTasks = agentData?.metadata?.completedTasks || [];
                        const totalDeliverables = agentData?.metadata?.deliverables?.length || 0;
                        
                        await this.lifecycleManager.transitionAgentState(agentId, 'completing', {
                            productionComplete: true,
                            tasksCompleted: completedTasks.length,
                            deliverablesCreated: totalDeliverables
                        });
                        
                        await this.lifecycleManager.transitionAgentState(agentId, 'complete', {
                            productionComplete: true,
                            finalTaskCount: completedTasks.length,
                            finalDeliverableCount: totalDeliverables,
                            completedAt: new Date()
                        });
                        
                        console.log(`‚úÖ ${agentId} completed (${completedTasks.length} tasks, ${totalDeliverables} deliverables)`);
                        
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Failed to complete agent ${agentId}:`, error.message);
                    }
                }
                
                console.log('üé≠ All agents completed successfully');
            }
            
            async executePhasesDependencyManaged(phases, completedPhases, phaseResults, phasePromises) {
                const remainingPhases = [...phases];
                
                while (remainingPhases.length > 0) {
                    // Find phases ready to execute (dependencies met)
                    const readyPhases = remainingPhases.filter(phase => 
                        phase.dependencies.every(dep => completedPhases.has(dep))
                    );
                    
                    if (readyPhases.length === 0) {
                        console.log('‚è≥ Waiting for dependencies to resolve...');
                        // Wait for any in-progress phase to complete
                        await Promise.race(Array.from(phasePromises.values()));
                        continue;
                    }
                    
                    // Execute ready phases ONE AT A TIME for proper timing
                    console.log(`üé≠ ${readyPhases.length} phases ready: ${readyPhases.map(p => p.name).join(', ')}`);
                    
                    // Process phases sequentially to avoid overwhelming the system
                    for (const phase of readyPhases) {
                        console.log(`\nüé¨ STARTING PHASE: ${phase.name}`);
                        console.log(`${'='.repeat(60)}`);
                        
                        const phaseStartTime = Date.now();
                        
                        try {
                            const result = await this.executePhaseWithIterations(phase);
                            
                            phaseResults[phase.name] = result;
                            completedPhases.add(phase.name);
                            
                            const phaseTime = ((Date.now() - phaseStartTime) / 1000 / 60).toFixed(1);
                            console.log(`‚úÖ PHASE COMPLETED: ${phase.name} (${phaseTime} minutes)`);
                            console.log(`${'='.repeat(60)}\n`);
                            
                        } catch (error) {
                            console.error(`‚ùå PHASE FAILED: ${phase.name}`, error);
                        }
                        
                        // Remove from remaining phases
                        const index = remainingPhases.indexOf(phase);
                        remainingPhases.splice(index, 1);
                    }
                    
                }
            }
            
            async executePhaseWithIterations(phase) {
                console.log(`üé≠ PHASE START: ${phase.name}`);
                console.log(`üë• Assigned agents: ${phase.requiredAgents?.join(', ') || 'Auto-assigned'}`);
                
                const phaseState = {
                    deliverables: [],
                    revisions: 0,
                    discussions: [],
                    collaborations: []
                };
                
                // Execute tasks in parallel where possible, in series where dependencies exist
                await this.executeTasksWithCollaboration(phase, phaseState);
                
                // Iterative refinement cycle
                await this.executeRefinementCycle(phase, phaseState);
                
                // Final review and approval
                await this.executeFinalReview(phase, phaseState);
                
                console.log(`üèÅ PHASE COMPLETE: ${phase.name}`);
                console.log(`   üìã Deliverables: ${phaseState.deliverables.length}`);
                console.log(`   üîÑ Revisions: ${phaseState.revisions}`);
                console.log(`   üí¨ Discussions: ${phaseState.discussions.length}`);
                
                // Save phase completion report
                this.savePhaseReport(phase, phaseState);
                
                return phaseState;
            }
            
            async executeTasksWithCollaboration(phase, phaseState) {
                // Group tasks by collaboration requirements
                const independentTasks = [];
                const collaborativeTasks = [];
                
                for (const taskId of phase.tasks) {
                    const agents = this.getAgentsForTask(taskId);
                    if (agents.length > 1) {
                        collaborativeTasks.push({ taskId, agents });
                    } else {
                        independentTasks.push({ taskId, agents });
                    }
                }
                
                // Execute independent tasks sequentially for realistic timing
                if (independentTasks.length > 0) {
                    console.log(`üé≠ Executing ${independentTasks.length} independent tasks with proper timing`);
                    for (const task of independentTasks) {
                        console.log(`üìã Starting independent task: ${task.taskId}`);
                        await this.executeCollaborativeTask(task.taskId, task.agents, phaseState);
                        console.log(`‚úÖ Completed independent task: ${task.taskId}`);
                    }
                }
                
                // Execute collaborative tasks with coordination
                for (const task of collaborativeTasks) {
                    console.log(`ü§ù Executing collaborative task: ${task.taskId} (${task.agents.length} agents)`);
                    await this.executeCollaborativeTask(task.taskId, task.agents, phaseState);
                }
            }
            
            async executeRefinementCycle(phase, phaseState) {
                const maxRevisions = 2;
                let revisionCycle = 0;
                
                while (revisionCycle < maxRevisions) {
                    revisionCycle++;
                    console.log(`üîÑ Revision cycle ${revisionCycle} for ${phase.name}`);
                    
                    // Agents review each other's work
                    const needsRevision = await this.conductPeerReview(phase, phaseState);
                    
                    if (!needsRevision) {
                        console.log(`‚ú® ${phase.name} approved without further revisions`);
                        break;
                    }
                    
                    // Execute revisions based on feedback
                    await this.executeRevisions(phase, phaseState);
                    phaseState.revisions++;
                }
            }
            
            async executeFinalReview(phase, phaseState) {
                console.log(`üëÅÔ∏è Final review for ${phase.name}`);
                
                // Supervisor agents review the work
                const supervisors = this.getSupervisorAgents(phase);
                for (const supervisor of supervisors) {
                    const review = await this.generateSupervisorReview(supervisor, phase, phaseState);
                    phaseState.discussions.push(review);
                    console.log(`üìù ${supervisor}: ${review.summary}`);
                }
            }
            
            async executeCollaborativeTask(taskId, agents, phaseState) {
                console.log(`üé¨ Collaborative Task: ${taskId}`);
                console.log(`üë• Collaborating agents: ${agents.filter(a => a !== 'summary-report').join(', ')}`);
                
                const taskDeliverables = [];
                const discussions = [];
                
                // Phase 1: Independent initial work with real Ollama integration
                console.log(`ü¶ô Starting Ollama-powered content generation for ${agents.length - 1} agents...`);
                const initialWork = [];
                
                // Process agents sequentially to avoid overwhelming Ollama
                for (const agentId of agents.filter(a => a !== 'summary-report')) {
                    await this.lifecycleManager.transitionAgentState(agentId, 'active');
                    console.log(`üé≠ ${agentId} starting deep creative work on ${taskId}...`);
                    
                    const deliverable = await this.generateTaskDeliverable(taskId, agentId);
                    
                    console.log(`‚ú® ${agentId} completed work: "${deliverable.title}"`);
                    if (deliverable.aiGenerated) {
                        console.log(`ü¶ô AI-generated content (${deliverable.content.length} chars from ${deliverable.model})`);
                    }
                    
                    initialWork.push({ agentId, deliverable });
                }
                
                // Phase 2: Cross-pollination and discussion
                const collaborationPoints = await this.generateCollaborationPoints(taskId, initialWork);
                for (const point of collaborationPoints) {
                    discussions.push(point);
                    console.log(`üí¨ Discussion: ${point.topic} (${point.participants.join(', ')})`);
                }
                
                // Phase 3: Refined deliverables based on collaboration
                for (const work of initialWork) {
                    const refinedDeliverable = await this.refineDeliverableFromCollaboration(
                        work.deliverable, discussions, work.agentId
                    );
                    taskDeliverables.push(refinedDeliverable);
                    
                    // Update agent metadata but keep them active for future tasks
                    const agentData = this.lifecycleManager.agentStates.get(work.agentId);
                    if (agentData) {
                        agentData.iterations++;
                        agentData.metadata.deliverables = agentData.metadata.deliverables || [];
                        agentData.metadata.deliverables.push(refinedDeliverable);
                        agentData.metadata.completedTasks = agentData.metadata.completedTasks || [];
                        agentData.metadata.completedTasks.push(taskId);
                        
                        // Keep agent active for future tasks - don't mark as complete yet
                        console.log(`‚ú® ${work.agentId} completed task ${taskId} - staying active for future work`);
                    }
                }
                
                // Store results
                phaseState.deliverables.push(...taskDeliverables);
                phaseState.discussions.push(...discussions);
                phaseState.collaborations.push({
                    task: taskId,
                    agents: agents.filter(a => a !== 'summary-report'),
                    deliverables: taskDeliverables.length,
                    discussions: discussions.length
                });
                
                // Update shared production state
                this.updateProductionState(taskId, taskDeliverables);
                
                console.log(`‚úÖ Collaborative task completed: ${taskId} (${taskDeliverables.length} deliverables, ${discussions.length} discussions)`);
                return taskDeliverables;
            }
            
            async generateCollaborationPoints(taskId, initialWork) {
                const collaborationTemplates = {
                    'story_outline': [
                        { topic: 'Character motivation alignment', participants: ['ai-playwright', 'dramaturge'] },
                        { topic: 'Narrative arc structure', participants: ['ai-playwright', 'creative-director'] }
                    ],
                    'thematic_composition': [
                        { topic: 'Musical themes matching story beats', participants: ['music-composer', 'ai-playwright'] },
                        { topic: 'Orchestration considerations', participants: ['music-composer', 'music-director'] }
                    ],
                    'visual_concept': [
                        { topic: 'Design cohesion across departments', participants: ['set-designer', 'costume-designer', 'lighting-designer'] },
                        { topic: 'Technical feasibility review', participants: ['set-designer', 'technical-director'] }
                    ],
                    'casting_process': [
                        { topic: 'Role requirements vs. available talent', participants: ['casting-director', 'voice-coach'] },
                        { topic: 'Character physicality needs', participants: ['casting-director', 'movement-coach'] }
                    ]
                };
                
                return collaborationTemplates[taskId] || [
                    { topic: `${taskId} collaboration discussion`, participants: initialWork.map(w => w.agentId).slice(0, 2) }
                ];
            }
            
            async refineDeliverableFromCollaboration(originalDeliverable, discussions, agentId) {
                const relevantDiscussions = discussions.filter(d => d.participants.includes(agentId));
                
                return {
                    ...originalDeliverable,
                    title: `${originalDeliverable.title} (Refined)`,
                    content: `${originalDeliverable.content}\n\n[Refined based on collaboration: ${relevantDiscussions.map(d => d.topic).join(', ')}]`,
                    collaborationPoints: relevantDiscussions.length,
                    refined: true,
                    originalVersion: originalDeliverable.title
                };
            }
            
            async conductPeerReview(phase, phaseState) {
                // 30% chance needs revision for realism
                const needsRevision = Math.random() < 0.3;
                
                if (needsRevision) {
                    console.log(`üîç Peer review identified areas for improvement in ${phase.name}`);
                } else {
                    console.log(`‚úÖ Peer review approved ${phase.name} quality`);
                }
                
                return needsRevision;
            }
            
            async executeRevisions(phase, phaseState) {
                console.log(`üìù Executing revisions for ${phase.name}`);
                // Simulate revision work on recent deliverables
                const recentDeliverables = phaseState.deliverables.slice(-2);
                for (const deliverable of recentDeliverables) {
                    deliverable.revised = true;
                    deliverable.revisionNotes = 'Quality improvements based on peer review';
                }
            }
            
            getSupervisorAgents(phase) {
                const supervisorMap = {
                    'Pre-Production Planning': ['executive-producer', 'creative-director'],
                    'Script Development - Phase 1': ['creative-director', 'dramaturge'],
                    'Musical Composition - Phase 1': ['music-director', 'creative-director'],
                    'Design Conceptualization': ['production-designer', 'technical-director'],
                    'Casting & Performance Preparation': ['creative-director', 'casting-director'],
                    'Technical Planning & Engineering': ['technical-director', 'stage-manager'],
                    'Marketing & Audience Development': ['marketing-director', 'executive-producer']
                };
                
                return supervisorMap[phase.name] || ['executive-producer'];
            }
            
            async generateSupervisorReview(supervisor, phase, phaseState) {
                return {
                    supervisor,
                    phase: phase.name,
                    summary: `Quality review completed - ${phaseState.deliverables.length} deliverables approved`,
                    recommendations: `Continue to ${phase.name} implementation phase`,
                    timestamp: new Date().toLocaleTimeString()
                };
            }
            
            updateProductionState(taskId, deliverables) {
                // Store deliverables for reporting system
                if (!this.taskDeliverables[taskId]) {
                    this.taskDeliverables[taskId] = [];
                }
                this.taskDeliverables[taskId].push(...deliverables);
                
                // Save deliverables to files
                this.saveDeliverablesAsFiles(taskId, deliverables);
                
                // Update shared production state for cross-phase dependencies
                if (taskId.includes('script') || taskId.includes('story')) {
                    this.productionState.script.versions.push(...deliverables);
                    this.productionState.script.currentVersion = deliverables[deliverables.length - 1];
                } else if (taskId.includes('music') || taskId.includes('composition')) {
                    this.productionState.music.compositions.push(...deliverables);
                } else if (taskId.includes('design') || taskId.includes('visual')) {
                    this.productionState.designs.set.push(...deliverables);
                }
            }

            saveDeliverablesAsFiles(taskId, deliverables) {
                try {
                    // Create downloadable files for each deliverable
                    deliverables.forEach((deliverable, index) => {
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                        const baseFilename = `${deliverable.agent}_${taskId}_${timestamp}`;
                        
                        // Save main deliverable file
                        const textContent = `# ${deliverable.title}
Agent: ${deliverable.agent}
Task: ${taskId}
Type: ${deliverable.type}
Generated: ${deliverable.timestamp}
AI Model: ${deliverable.model || 'Unknown'}
AI Generated: ${deliverable.aiGenerated ? 'Yes' : 'No'}

## Content:
${deliverable.content}

${deliverable.collaborationPoints ? `\n## Collaboration Points: ${deliverable.collaborationPoints}` : ''}
${deliverable.refined ? `\n## Refined Version of: ${deliverable.originalVersion}` : ''}
${deliverable.musicData ? `\n## ABC Notation Validation:
Valid: ${deliverable.musicData.isValid}
Elements Found: ${Object.entries(deliverable.musicData.validation || {}).filter(([k,v]) => v).map(([k]) => k).join(', ')}
${deliverable.musicData.error ? `Error: ${deliverable.musicData.error}` : ''}` : ''}
${deliverable.visualDesignData ? `\n## Visual Design Validation:
Valid: ${deliverable.visualDesignData.isValid}
Quality Score: ${deliverable.visualDesignData.qualityScore}/100
Sections Found: ${deliverable.visualDesignData.validation?.sectionsFound?.join(', ') || 'None'}
Measurements: ${deliverable.visualDesignData.validation?.measurementsCount || 0}
Technical Specs: ${deliverable.visualDesignData.validation?.technicalSpecsCount || 0}
${deliverable.visualDesignData.error ? `Error: ${deliverable.visualDesignData.error}` : ''}` : ''}
${deliverable.performanceCoachingData ? `\n## Performance Coaching Validation:
Valid: ${deliverable.performanceCoachingData.isValid}
Quality Score: ${deliverable.performanceCoachingData.qualityScore}/100
Sections Found: ${deliverable.performanceCoachingData.validation?.sectionsFound?.join(', ') || 'None'}
Instructions: ${deliverable.performanceCoachingData.validation?.instructionCount || 0}
Technical Terms: ${deliverable.performanceCoachingData.validation?.technicalTermCount || 0}
Safety Considerations: ${deliverable.performanceCoachingData.validation?.safetyConsiderationsCount || 0}
${deliverable.performanceCoachingData.error ? `Error: ${deliverable.performanceCoachingData.error}` : ''}` : ''}
${deliverable.technicalProductionData ? `\n## Technical Production Validation:
Valid: ${deliverable.technicalProductionData.isValid}
Quality Score: ${deliverable.technicalProductionData.qualityScore}/100
Sections Found: ${deliverable.technicalProductionData.validation?.sectionsFound?.join(', ') || 'None'}
Equipment Specs: ${deliverable.technicalProductionData.validation?.equipmentSpecsCount || 0}
Technical Measurements: ${deliverable.technicalProductionData.validation?.measurementsCount || 0}
Safety Considerations: ${deliverable.technicalProductionData.validation?.safetyConsiderationsCount || 0}
Professional Terms: ${deliverable.technicalProductionData.validation?.professionalTermsCount || 0}
${deliverable.technicalProductionData.error ? `Error: ${deliverable.technicalProductionData.error}` : ''}` : ''}
${deliverable.administrativeMarketingData ? `\n## Administrative/Marketing Validation:
Valid: ${deliverable.administrativeMarketingData.isValid}
Quality Score: ${deliverable.administrativeMarketingData.qualityScore}/100
Sections Found: ${deliverable.administrativeMarketingData.validation?.sectionsFound?.join(', ') || 'None'}
KPI Metrics: ${deliverable.administrativeMarketingData.validation?.kpiMetricsCount || 0}
Timeline Elements: ${deliverable.administrativeMarketingData.validation?.timelineElementsCount || 0}
Budget Elements: ${deliverable.administrativeMarketingData.validation?.budgetElementsCount || 0}
Professional Terms: ${deliverable.administrativeMarketingData.validation?.professionalTermsCount || 0}
${deliverable.administrativeMarketingData.error ? `Error: ${deliverable.administrativeMarketingData.error}` : ''}` : ''}
${deliverable.specializedLeadershipData ? `\n## Specialized Leadership Validation:
Valid: ${deliverable.specializedLeadershipData.isValid}
Quality Score: ${deliverable.specializedLeadershipData.qualityScore}/100
Sections Found: ${deliverable.specializedLeadershipData.validation?.sectionsFound?.join(', ') || 'None'}
Executive Terms: ${deliverable.specializedLeadershipData.validation?.executiveTermsCount || 0}
Financial Metrics: ${deliverable.specializedLeadershipData.validation?.financialMetricsCount || 0}
Timeline Elements: ${deliverable.specializedLeadershipData.validation?.timelineElementsCount || 0}
Quality Frameworks: ${deliverable.specializedLeadershipData.validation?.qualityFrameworksCount || 0}
${deliverable.specializedLeadershipData.error ? `Error: ${deliverable.specializedLeadershipData.error}` : ''}` : ''}
${deliverable.scriptDevelopmentData ? `\n## Script Development Validation:
Valid: ${deliverable.scriptDevelopmentData.isValid}
Quality Score: ${deliverable.scriptDevelopmentData.qualityScore}/100
Sections Found: ${deliverable.scriptDevelopmentData.validation?.sectionsFound?.join(', ') || 'None'}
Script Terms: ${deliverable.scriptDevelopmentData.validation?.scriptTermsCount || 0}
Editorial Terms: ${deliverable.scriptDevelopmentData.validation?.editorialTermsCount || 0}
Quality Metrics: ${deliverable.scriptDevelopmentData.validation?.qualityMetricsCount || 0}
Reference Elements: ${deliverable.scriptDevelopmentData.validation?.referenceElementsCount || 0}
${deliverable.scriptDevelopmentData.error ? `Error: ${deliverable.scriptDevelopmentData.error}` : ''}` : ''}
---
Generated by Enhanced Theater Production System
Dreams of Tomorrow - Musical Theater Production
`;

                        this.downloadFile(textContent, `${baseFilename}.txt`, 'text/plain');
                        console.log(`üíæ Saved deliverable: ${baseFilename}.txt`);
                        
                        // If this deliverable contains valid ABC notation, save a separate .abc file and process audio
                        if (deliverable.musicData && deliverable.musicData.isValid && deliverable.musicData.abcContent) {
                            const abcContent = deliverable.musicData.abcContent;
                            this.downloadFile(abcContent, `${baseFilename}.abc`, 'text/plain');
                            console.log(`üéµ Saved ABC notation: ${baseFilename}.abc`);
                            
                            // Also save enhanced ABC with metadata
                            const enhancedABCContent = `% Generated by ${deliverable.agent} for Dreams of Tomorrow
% Task: ${taskId}
% Timestamp: ${deliverable.timestamp}
% AI Model: ${deliverable.model || 'Unknown'}

${abcContent}`;
                            
                            this.downloadFile(enhancedABCContent, `${baseFilename}_enhanced.abc`, 'text/plain');
                            console.log(`üéº Saved enhanced ABC: ${baseFilename}_enhanced.abc`);
                            
                            // TODO: Audio processing will be implemented in Phase 2 with proper tools
                            console.log(`üéº ABC notation ready for audio processing: ${baseFilename}.abc`);
                        }
                    });
                    
                    // Also save a task summary file
                    this.saveTaskSummary(taskId, deliverables);
                    
                } catch (error) {
                    console.error(`‚ùå Failed to save deliverables for ${taskId}:`, error);
                }
            }

            downloadFile(content, filename, mimeType = 'text/plain') {
                try {
                    // Create downloadable blob
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    
                    // Auto-download the file
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error(`‚ùå Failed to download file ${filename}:`, error);
                }
            }

            // PHASE 2 TODO: Real ABC to Audio Processing
            // This will implement actual ABC ‚Üí MIDI ‚Üí Audio conversion using:
            // - ABCJS.synth for proper ABC parsing and audio synthesis
            // - timidity-sf2 for MIDI playback with soundfonts  
            // - WebAudioFont for GM instrument synthesis
            async processABCToAudio_FUTURE_IMPLEMENTATION(deliverable, baseFilename) {
                try {
                    if (!deliverable.musicData || !deliverable.musicData.isValid) {
                        console.warn(`‚ö†Ô∏è Cannot process audio for ${deliverable.agent}: No valid ABC notation`);
                        return;
                    }

                    const abcContent = deliverable.musicData.abcContent;
                    console.log(`üéµ Processing ABC to audio for ${deliverable.agent}...`);

                    // Use ABCJS to parse and generate MIDI
                    const abcOptions = {
                        qpm: 120, // Quarter notes per minute
                        program: 0, // General MIDI program (0 = Acoustic Grand Piano)
                        chordsOff: false,
                        voicesOff: false
                    };

                    try {
                        // Parse ABC notation
                        const visualObj = ABCJS.renderAbc("*", abcContent, { 
                            responsive: "resize",
                            viewportHorizontal: true,
                            staffwidth: 600
                        });

                        if (visualObj && visualObj.length > 0) {
                            console.log(`üéº ABC parsed successfully for ${deliverable.agent}`);

                            // Generate MIDI from parsed ABC
                            const midiBuffer = ABCJS.synth.getMidiFile(abcContent, abcOptions);
                            
                            if (midiBuffer) {
                                // Save MIDI file
                                this.downloadFile(midiBuffer, `${baseFilename}.mid`, 'audio/midi');
                                console.log(`üéπ Generated MIDI: ${baseFilename}.mid`);

                                // Attempt to synthesize audio using Web Audio API
                                await this.synthesizeAudioFromMIDI(midiBuffer, baseFilename, deliverable);
                            } else {
                                console.warn(`‚ö†Ô∏è Failed to generate MIDI for ${deliverable.agent}`);
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è Failed to parse ABC notation for ${deliverable.agent}`);
                        }

                    } catch (parseError) {
                        console.error(`‚ùå ABC parsing error for ${deliverable.agent}:`, parseError);
                        
                        // Fallback: try procedural audio generation
                        await this.generateProceduralAudio(abcContent, baseFilename, deliverable);
                    }

                } catch (error) {
                    console.error(`‚ùå Audio processing failed for ${deliverable.agent}:`, error);
                }
            }

            async synthesizeAudioFromMIDI(midiBuffer, baseFilename, deliverable) {
                try {
                    console.log(`üîä Attempting audio synthesis for ${baseFilename}...`);
                    
                    // For now, we'll create a procedural audio representation
                    // In Phase 2, we'll integrate proper MIDI synthesis
                    await this.generateProceduralAudio(deliverable.musicData.abcContent, baseFilename, deliverable);
                    
                } catch (error) {
                    console.error(`‚ùå Audio synthesis failed for ${baseFilename}:`, error);
                }
            }

            async generateProceduralAudio(abcContent, baseFilename, deliverable) {
                try {
                    console.log(`üéõÔ∏è Generating procedural audio for ${baseFilename}...`);

                    // Create Web Audio context
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const sampleRate = audioContext.sampleRate;
                    const duration = 10; // 10 seconds default
                    const frameCount = sampleRate * duration;

                    // Create buffer for audio
                    const audioBuffer = audioContext.createBuffer(1, frameCount, sampleRate);
                    const channelData = audioBuffer.getChannelData(0);

                    // Extract basic musical information from ABC
                    const keyMatch = abcContent.match(/K:\s*([A-G][#b]?[m]?)/);
                    const meterMatch = abcContent.match(/M:\s*([\d\/]+)/);
                    const key = keyMatch ? keyMatch[1] : 'C';
                    const meter = meterMatch ? meterMatch[1] : '4/4';

                    // Generate a simple melody based on the key
                    const baseFreq = this.getKeyFrequency(key);
                    const scale = this.generateScale(baseFreq);

                    // Create a simple melody
                    for (let i = 0; i < frameCount; i++) {
                        const time = i / sampleRate;
                        const noteIndex = Math.floor(time * 2) % scale.length; // Change note every 0.5 seconds
                        const frequency = scale[noteIndex];
                        
                        // Generate sine wave with envelope
                        const envelope = Math.exp(-time * 0.3); // Decay envelope
                        const sample = Math.sin(2 * Math.PI * frequency * time) * envelope * 0.3;
                        channelData[i] = sample;
                    }

                    // Convert to WAV and download
                    const wavBuffer = this.audioBufferToWav(audioBuffer);
                    this.downloadFile(wavBuffer, `${baseFilename}.wav`, 'audio/wav');
                    console.log(`üéµ Generated audio: ${baseFilename}.wav`);

                } catch (error) {
                    console.error(`‚ùå Procedural audio generation failed:`, error);
                }
            }

            getKeyFrequency(key) {
                const frequencies = {
                    'C': 261.63, 'C#': 277.18, 'Db': 277.18,
                    'D': 293.66, 'D#': 311.13, 'Eb': 311.13,
                    'E': 329.63, 'F': 349.23, 'F#': 369.99,
                    'Gb': 369.99, 'G': 392.00, 'G#': 415.30,
                    'Ab': 415.30, 'A': 440.00, 'A#': 466.16,
                    'Bb': 466.16, 'B': 493.88
                };
                return frequencies[key] || frequencies['C'];
            }

            generateScale(baseFreq) {
                // Generate major scale
                const intervals = [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8];
                return intervals.map(interval => baseFreq * interval);
            }

            audioBufferToWav(buffer) {
                const length = buffer.length;
                const arrayBuffer = new ArrayBuffer(44 + length * 2);
                const view = new DataView(arrayBuffer);

                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, buffer.sampleRate, true);
                view.setUint32(28, buffer.sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * 2, true);

                // Convert float samples to 16-bit PCM
                const channelData = buffer.getChannelData(0);
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    view.setInt16(offset, sample * 0x7FFF, true);
                    offset += 2;
                }

                return arrayBuffer;
            }

            saveTaskSummary(taskId, deliverables) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `TASK_SUMMARY_${taskId}_${timestamp}.md`;
                
                const summaryContent = `# Task Summary: ${taskId.replace('_', ' ').toUpperCase()}

**Generated:** ${new Date().toLocaleString()}
**Task ID:** ${taskId}
**Agents Involved:** ${deliverables.map(d => d.agent).join(', ')}
**Total Deliverables:** ${deliverables.length}

## Deliverables Overview

${deliverables.map((d, i) => `
### ${i + 1}. ${d.title}
- **Agent:** ${d.agent}
- **Type:** ${d.type}
- **AI Generated:** ${d.aiGenerated ? 'Yes' : 'No'}
- **Model:** ${d.model || 'Unknown'}
- **Length:** ${d.content?.length || 0} characters

**Preview:**
${d.content?.substring(0, 200)}${d.content?.length > 200 ? '...' : ''}

---
`).join('')}

## Production Context
This task is part of the "Dreams of Tomorrow" musical theater production, a comprehensive AI-driven creative collaboration system involving 36 specialized agents.

**Generated by Enhanced Theater Production System**
`;

                const blob = new Blob([summaryContent], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log(`üìÑ Saved task summary: ${filename}`);
            }

            savePhaseReport(phase, phaseState) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `PHASE_REPORT_${phase.name.replace(/\s+/g, '_')}_${timestamp}.md`;
                
                const reportContent = `# Phase Report: ${phase.name}

**Generated:** ${new Date().toLocaleString()}
**Phase Duration:** ${phase.duration ? `${(phase.duration / 60000).toFixed(1)} minutes planned` : 'Variable'}
**Required Agents:** ${phase.requiredAgents?.join(', ') || 'Auto-assigned'}

## Summary
- **Total Deliverables:** ${phaseState.deliverables.length}
- **Revisions Made:** ${phaseState.revisions}
- **Discussions Held:** ${phaseState.discussions.length}
- **Collaborations:** ${phaseState.collaborations.length}

## Tasks Completed
${phase.tasks.map(taskId => {
    const taskDeliverables = phaseState.deliverables.filter(d => d.task === taskId);
    return `
### ${taskId.replace('_', ' ').toUpperCase()}
- **Deliverables:** ${taskDeliverables.length}
- **Agents:** ${taskDeliverables.map(d => d.agent).join(', ')}
- **AI Generated:** ${taskDeliverables.filter(d => d.aiGenerated).length}/${taskDeliverables.length}
${taskDeliverables.map(d => `  - ${d.title} (${d.agent})`).join('\n')}
`;
}).join('')}

## Deliverables Details
${phaseState.deliverables.map((d, i) => `
### ${i + 1}. ${d.title}
- **Agent:** ${d.agent}
- **Type:** ${d.type}
- **AI Model:** ${d.model || 'Unknown'}
- **Length:** ${d.content?.length || 0} characters
- **Collaboration Points:** ${d.collaborationPoints || 0}

**Content Preview:**
${d.content?.substring(0, 300)}${d.content?.length > 300 ? '...' : ''}

---
`).join('')}

## Collaborations
${phaseState.collaborations.map((collab, i) => `
### ${i + 1}. ${collab.task.replace('_', ' ').toUpperCase()}
- **Agents:** ${collab.agents.join(', ')}
- **Deliverables:** ${collab.deliverables}
- **Discussions:** ${collab.discussions}
`).join('')}

## Production Context
This phase is part of the "Dreams of Tomorrow" musical theater production, using a 36-agent AI collaboration system with real Ollama LLM integration.

**Generated by Enhanced Theater Production System**
`;

                const blob = new Blob([reportContent], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log(`üìã Saved phase report: ${filename}`);
            }

            
            async generateTaskDeliverable(taskId, agentId) {
                const deliverableTemplates = {
                    // Pre-Production Planning
                    'concept_development': {
                        'executive-producer': { title: 'Production Concept Overview', content: 'Vision statement, target audience, creative goals for Dreams of Tomorrow musical theater production.', type: 'concept' },
                        'creative-director': { title: 'Artistic Vision Document', content: 'Creative direction, thematic elements, artistic approach and overall aesthetic vision.', type: 'creative' }
                    },
                    'initial_research': {
                        'dramaturge': { title: 'Historical & Cultural Research', content: 'Background research on urban development, community dynamics, and relevant historical context.', type: 'research' },
                        'creative-director': { title: 'Creative Research Brief', content: 'Artistic influences, style references, and creative inspiration sources.', type: 'research' }
                    },
                    'budget_planning': {
                        'executive-producer': { title: 'Production Budget Plan', content: 'Comprehensive budget breakdown covering all production phases, personnel, and resources.', type: 'budget' },
                        'technical-director': { title: 'Technical Budget Requirements', content: 'Equipment, materials, and technical resource cost analysis.', type: 'budget' }
                    },
                    'venue_planning': {
                        'executive-producer': { title: 'Venue Requirements & Strategy', content: 'Theater selection criteria, capacity requirements, scheduling considerations.', type: 'planning' },
                        'house-manager': { title: 'Venue Operations Plan', content: 'Audience services, accessibility, front-of-house operations planning.', type: 'operations' }
                    },

                    // Script Development - Phase 1
                    'story_outline': {
                        'ai-playwright': { title: 'Story Structure & Plot Outline', content: 'Three-act structure, character arcs, major plot points for Dreams of Tomorrow.', type: 'script' },
                        'dramaturge': { title: 'Narrative Analysis & Structure', content: 'Story development analysis, thematic coherence, dramatic structure evaluation.', type: 'analysis' }
                    },
                    'character_creation': {
                        'ai-playwright': { title: 'Character Development & Profiles', content: 'Main character biographies, motivations, relationships, and character arcs.', type: 'character' },
                        'creative-director': { title: 'Character Concept Direction', content: 'Visual and performance concepts for character development and portrayal.', type: 'creative' }
                    },
                    'initial_script_draft': {
                        'ai-playwright': { title: 'Act I Draft Script', content: 'Initial draft of Act I including dialogue, stage directions, and scene structure.', type: 'script' },
                        'script-editor': { title: 'Script Development Notes', content: 'Structural feedback, pacing notes, and development suggestions for initial draft.', type: 'notes' }
                    },
                    'dramaturgical_review': {
                        'dramaturge': { title: 'Script Analysis & Recommendations', content: 'Dramatic structure evaluation, thematic analysis, and improvement recommendations.', type: 'analysis' },
                        'creative-director': { title: 'Creative Review & Direction', content: 'Artistic evaluation and creative direction for script development.', type: 'creative' }
                    },

                    // Musical Composition - Phase 1  
                    'thematic_composition': {
                        'music-composer': { title: 'Main Theme Compositions', content: 'Primary musical themes, leitmotifs, and melodic concepts for the production.', type: 'music' },
                        'creative-director': { title: 'Musical Direction & Style Guide', content: 'Musical style direction, thematic integration with overall artistic vision.', type: 'creative' }
                    },
                    'song_concepts': {
                        'music-composer': { title: 'Song Structure & Concepts', content: 'Individual song concepts, lyrical themes, and musical arrangements.', type: 'music' },
                        'music-director': { title: 'Musical Direction & Arrangement Plans', content: 'Orchestration approach, vocal arrangements, and performance direction.', type: 'direction' }
                    },
                    'musical_structure': {
                        'music-composer': { title: 'Overall Musical Architecture', content: 'Musical pacing, song placement, instrumental interludes, and musical flow.', type: 'music' },
                        'dramaturge': { title: 'Musical Dramatic Integration', content: 'Analysis of musical-dramatic integration and story support through music.', type: 'analysis' }
                    },
                    'demo_recordings': {
                        'music-composer': { title: 'Demo Recording Plans', content: 'Recording strategy, instrumentation plans, and demo production approach.', type: 'music' },
                        'rehearsal-pianist': { title: 'Piano Arrangements & Rehearsal Prep', content: 'Piano reductions, rehearsal arrangements, and practice materials.', type: 'music' }
                    },

                    // Script and Story Development
                    'script_creation': {
                        'ai-playwright': { title: 'Act I Scene Outline', content: 'Opening sequence with character introductions and conflict setup. Duration: 25 minutes.', type: 'script' },
                        'script-editor': { title: 'Script Revision Notes', content: 'Character development improvements, pacing adjustments, dialogue refinements.', type: 'notes' },
                        'dramaturge': { title: 'Historical Context Research', content: 'Period accuracy verification, cultural authenticity guidelines.', type: 'research' }
                    },
                    'character_development': {
                        'ai-playwright': { title: 'Character Profiles', content: 'Protagonist: Maya Chen (age 28, architect). Antagonist: Corporate developer.', type: 'character' },
                        'dramaturge': { title: 'Character Arc Analysis', content: 'Hero\'s journey structure, relationship dynamics, growth trajectories.', type: 'analysis' }
                    },
                    'dialogue_refinement': {
                        'ai-playwright': { title: 'Refined Dialogue - Act I', content: 'Natural conversation flow, subtext integration, character voice consistency.', type: 'script' },
                        'script-editor': { title: 'Line-by-Line Edits', content: 'Grammar corrections, rhythm improvements, emotional beats.', type: 'edits' }
                    },
                    
                    // Music and Audio
                    'musical_composition': {
                        'music-composer': { title: 'Opening Theme - "Dreams of Tomorrow"', content: 'Key: A Major, Tempo: 120 BPM, Duration: 4:30. Orchestral arrangement with strings and woodwinds.', type: 'music' },
                        'music-director': { title: 'Musical Score Arrangement', content: 'Full orchestration, instrumental parts, conductor\'s score.', type: 'score' }
                    },
                    'song_arrangements': {
                        'music-composer': { title: 'Ballad - "Heart of the City"', content: 'Emotional centerpiece, piano-driven, key of D minor.', type: 'music' },
                        'music-director': { title: 'Vocal Harmonies', content: 'Three-part harmony, soprano/alto/tenor arrangements.', type: 'vocals' }
                    },
                    
                    // Visual Design
                    'design_development': {
                        'set-designer': { title: 'Urban Landscape Set Design', content: 'Multi-level cityscape with moving platforms, LED backdrop integration.', type: 'design' },
                        'costume-designer': { title: 'Period Costume Concepts', content: 'Modern professional wear with historical influences, color palette: blues and grays.', type: 'costume' },
                        'lighting-designer': { title: 'Lighting Plot - Act I', content: '45 fixtures, color temperature transitions, mood lighting cues.', type: 'lighting' }
                    },
                    'visual_elements': {
                        'projection-designer': { title: 'Digital Backdrop Sequences', content: 'City skyline animations, weather effects, time-lapse sequences.', type: 'projection' },
                        'makeup-artist': { title: 'Character Makeup Designs', content: 'Natural look with subtle aging effects, special effects for transformation scenes.', type: 'makeup' }
                    },
                    
                    // Technical Production
                    'technical_planning': {
                        'technical-director': { title: 'Safety Protocol Document', content: 'Rigging safety, fire safety procedures, emergency evacuation plans.', type: 'safety' },
                        'stage-manager': { title: 'Rehearsal Schedule', content: '8-week rehearsal timeline, blocking sessions, technical rehearsals.', type: 'schedule' }
                    },
                    'audio_design': {
                        'sound-designer': { title: 'Sound Effects Library', content: 'Urban ambiance, weather sounds, mechanical effects. 127 custom audio files.', type: 'audio' },
                        'audio-engineer': { title: 'Sound System Configuration', content: '24-channel mixing console, speaker placement diagram, monitor setup.', type: 'technical' }
                    },
                    
                    // Marketing and Outreach
                    'audience_engagement': {
                        'marketing-director': { title: 'Marketing Campaign Strategy', content: 'Social media timeline, press release schedule, community partnerships.', type: 'marketing' },
                        'audience-development': { title: 'Community Outreach Plan', content: 'School group discounts, senior matinees, accessibility accommodations.', type: 'outreach' }
                    },
                    'promotional_materials': {
                        'publicist': { title: 'Press Kit Materials', content: 'Director interviews, behind-the-scenes photos, production notes.', type: 'publicity' },
                        'social-media-manager': { title: 'Social Media Content Calendar', content: 'Daily posts, rehearsal updates, cast spotlights, countdown posts.', type: 'social' }
                    },
                    
                    // Performance and Coaching
                    'performance_coaching': {
                        'voice-coach': { title: 'Vocal Training Program', content: 'Breathing exercises, projection techniques, vocal health guidelines.', type: 'coaching' },
                        'method-acting-coach': { title: 'Character Method Workshops', content: 'Emotional memory exercises, improvisation sessions, character immersion techniques.', type: 'training' },
                        'movement-coach': { title: 'Stage Movement Choreography', content: 'Blocking patterns, gesture vocabulary, spatial awareness exercises.', type: 'movement' }
                    }
                };
                
                const taskTemplates = deliverableTemplates[taskId];
                let template;
                
                if (!taskTemplates || !taskTemplates[agentId]) {
                    // Create template for unmapped tasks
                    template = {
                        title: `${agentId.replace('-', ' ')} Professional Work: ${taskId.replace('_', ' ')}`,
                        content: `Detailed professional work for ${taskId} task`,
                        type: 'professional'
                    };
                    console.log(`‚ö†Ô∏è No template for ${agentId} on ${taskId}, using generic template`);
                } else {
                    template = taskTemplates[agentId];
                }
                
                // Use Ollama to generate real professional theater content
                try {
                    const contextualPrompts = {
                        'ai-playwright': `Write detailed script content, character descriptions, or dialogue for "${taskId}". Create authentic theatrical writing.`,
                        'dramaturge': `Please respond with structured dramaturgical analysis for "${taskId}". Generate comprehensive script analysis including:
- STRUCTURE: Three-act analysis, plot progression, dramatic tension curves
- CHARACTER: Character development arcs, relationships, motivation consistency
- THEME: Thematic coherence, symbolic elements, dramatic meaning analysis
- RESEARCH: Historical accuracy, cultural context, source material fidelity
- REVISION: Specific improvement recommendations with line/scene references
- VALIDATION: Script quality metrics, dramatic effectiveness assessment
Format as professional dramaturgical documentation.`,
                        'script-editor': `Please respond with structured script editing specifications for "${taskId}". Generate comprehensive editorial documentation including:
- FORMAT: Industry-standard script formatting, scene headers, character names
- DIALOGUE: Line-by-line analysis, rhythm, subtext, character voice consistency
- STRUCTURE: Scene flow, pacing adjustments, transition improvements
- REVISIONS: Tracked changes with version control, editorial notes system
- STANDARDS: Grammar, spelling, punctuation, industry style guide compliance
- VALIDATION: Editorial quality scoring, readability metrics, consistency checks
Format as professional script editing documentation.`,
                        'music-composer': `Please respond in ABC notation format. Compose complete musical pieces for "${taskId}". Generate actual ABC notation including melody, rhythm, key signature, and time signature. Example format:
X:1
T:Song Title
M:4/4
L:1/8
K:C
|: C4 D4 | E4 F4 | G8 :|`,
                        'music-director': `Please respond in ABC notation format. Create orchestral arrangements and vocal harmonies for "${taskId}". Generate ABC notation with harmony parts and orchestration instructions. Include tempo markings and dynamics.`,
                        'sound-designer': `Please respond with structured sound design specifications for "${taskId}". Generate comprehensive audio technical plans including:
- EQUIPMENT: Audio hardware, software, and synthesis tools with specifications
- EFFECTS: Detailed sound effect descriptions with technical parameters
- SYNTHESIS: Frequency ranges, waveforms, processing chains, and synthesis methods
- IMPLEMENTATION: Web Audio API code, file formats, and playback systems
- TIMING: Cue placement, duration specifications, and synchronization requirements
Format as professional sound design documentation.`,
                        'audio-engineer': `Please respond with structured audio engineering specifications for "${taskId}". Generate comprehensive audio technical documentation including:
- EQUIPMENT: Mixing consoles, processors, and monitoring systems with models
- SETUP: Signal flow diagrams, routing, and equipment configuration
- PROCESSING: EQ curves, dynamics, spatial positioning, and effects chains
- RECORDING: Microphone placement, recording levels, and capture specifications
- DELIVERY: Mix formats, mastering specifications, and distribution requirements
Format as professional audio engineering documentation.`,
                        'rehearsal-pianist': `Please respond in ABC notation format. Create piano arrangements and accompaniments for "${taskId}". Generate ABC notation for piano parts, lead sheets, and practice materials.`,
                        'set-designer': `Please respond with structured set design specifications for "${taskId}". Generate detailed technical plans including:
- DIMENSIONS: Width x Depth x Height in feet
- MATERIALS: Specific construction materials and quantities  
- BLUEPRINT: ASCII art layout or detailed written description
- TECHNICAL: Rigging points, safety considerations, assembly instructions
Format as structured data with clear sections.`,
                        'costume-designer': `Please respond with detailed costume design specifications for "${taskId}". Generate comprehensive costume plans including:
- CHARACTER: Role and costume purpose
- DESIGN: Visual style, silhouette, period accuracy
- MATERIALS: Fabric types, colors (Pantone codes), textures
- CONSTRUCTION: Pattern pieces, measurements, assembly notes
- BUDGET: Cost estimates and sourcing information
Format as structured specifications.`,
                        'lighting-designer': `Please respond with structured lighting design specifications for "${taskId}". Generate technical lighting plots including:
- FIXTURES: Specific light types, positions, and focus
- COLORS: Gel numbers and color temperatures  
- PROGRAMMING: Cue sequences and timing
- TECHNICAL: Power requirements, cable runs, control systems
- EFFECTS: Special lighting effects and atmosphere
Format as structured technical documentation.`,
                        'casting-director': `Please respond with structured casting specifications for "${taskId}". Generate comprehensive casting documentation including:
- BREAKDOWN: Detailed character descriptions with age, type, and skill requirements
- AUDITION: Audition process timeline, evaluation criteria, callback procedures
- TALENT: Database of potential performers with contact information and notes
- CONTRACTS: Offer terms, rehearsal commitments, performance schedules
- DIVERSITY: Inclusion metrics, representation goals, accessibility accommodations
Format as professional casting documentation.`,
                        'marketing-director': `Please respond with structured marketing campaign specifications for "${taskId}". Generate comprehensive marketing documentation including:
- STRATEGY: Campaign objectives, target demographics, positioning statements
- CHANNELS: Media mix allocation, platform-specific strategies, budget distribution
- METRICS: KPIs, ROI projections, tracking methodologies, success benchmarks
- TIMELINE: Campaign phases, launch dates, milestone deliverables
- BUDGET: Detailed cost breakdowns, vendor contracts, contingency planning
Format as professional marketing documentation.`,
                        'publicist': `Please respond with structured publicity campaign specifications for "${taskId}". Generate comprehensive PR documentation including:
- PRESS: Press release templates, media kit contents, story angles
- CONTACTS: Media database with outlets, journalists, submission deadlines
- COVERAGE: Tracking systems for mentions, reviews, feature stories
- EVENTS: Press conference planning, photo opportunities, interview schedules
- METRICS: PR value calculations, reach analysis, sentiment tracking
Format as professional publicity documentation.`,
                        'social-media-manager': `Please respond with structured social media campaign specifications for "${taskId}". Generate comprehensive social media documentation including:
- CONTENT: Content calendar with post types, hashtags, visual assets
- PLATFORMS: Platform-specific strategies for Instagram, Facebook, Twitter, TikTok
- ENGAGEMENT: Community management protocols, response templates, influencer outreach
- ANALYTICS: Engagement rates, follower growth, conversion tracking
- SCHEDULE: Posting times, content batching, campaign coordination
Format as professional social media documentation.`,
                        'audience-development': `Please respond with structured audience development specifications for "${taskId}". Generate comprehensive audience strategy documentation including:
- DEMOGRAPHICS: Target audience profiles, market segmentation, persona development
- OUTREACH: Community partnership programs, educational initiatives, group sales
- ACCESSIBILITY: ADA compliance, sensory-friendly performances, translation services
- RETENTION: Subscriber programs, loyalty initiatives, feedback systems
- METRICS: Attendance tracking, demographic analysis, conversion rates
Format as professional audience development documentation.`,
                        'house-manager': `Please respond with structured house management specifications for "${taskId}". Generate comprehensive venue operations documentation including:
- OPERATIONS: Front-of-house procedures, staff assignments, service standards
- SAFETY: Emergency protocols, evacuation procedures, medical response plans
- LOGISTICS: Seating management, accessibility services, patron flow optimization
- STAFFING: Usher training, box office procedures, concession operations
- REPORTS: Nightly attendance, incident documentation, customer feedback
Format as professional house management documentation.`,
                        'assistant-director': `Please respond with structured assistant direction specifications for "${taskId}". Generate comprehensive production coordination documentation including:
- SCHEDULES: Rehearsal calendars, call sheets, conflict tracking
- COMMUNICATION: Daily reports, production meeting minutes, cast notifications
- LOGISTICS: Space allocation, resource coordination, transportation planning
- DOCUMENTATION: Blocking notation, script changes, performance notes
- COORDINATION: Department liaison, creative team support, problem resolution
Format as professional assistant direction documentation.`,
                        'executive-producer': `Please respond with structured executive production specifications for "${taskId}". Generate comprehensive executive decision documentation including:
- STRATEGY: Production vision, market positioning, competitive analysis
- BUDGET: Financial planning, cost projections, revenue forecasts, ROI analysis
- DECISIONS: Executive approvals, resource allocation, strategic priorities
- OVERSIGHT: Quality standards, timeline management, risk assessment
- STAKEHOLDERS: Investor relations, board reports, partnership agreements
Format as professional executive production documentation.`,
                        'creative-director': `Please respond with structured creative direction specifications for "${taskId}". Generate comprehensive artistic leadership documentation including:
- VISION: Artistic concept, thematic coherence, creative philosophy
- STANDARDS: Quality benchmarks, creative consistency, artistic integrity
- COORDINATION: Cross-departmental artistic alignment, creative team leadership
- DEVELOPMENT: Creative process guidance, artistic problem-solving
- REVIEW: Creative approval criteria, artistic quality assessment
Format as professional creative direction documentation.`,
                        'technical-director': `Please respond with structured technical direction specifications for "${taskId}". Generate comprehensive technical leadership documentation including:
- SPECIFICATIONS: Technical requirements, equipment standards, safety protocols
- PLANNING: Implementation timelines, resource allocation, technical milestones
- OVERSIGHT: Quality control, safety compliance, technical troubleshooting
- COORDINATION: Department integration, technical team leadership
- APPROVAL: Technical sign-offs, safety certifications, equipment validation
Format as professional technical direction documentation.`,
                        'production-designer': `Please respond with structured production design coordination specifications for "${taskId}". Generate comprehensive design leadership documentation including:
- CONCEPT: Overall design vision, aesthetic coherence, stylistic direction
- COORDINATION: Cross-design team integration, visual consistency standards
- SPECIFICATIONS: Design requirements, material standards, construction oversight
- APPROVAL: Design review criteria, quality benchmarks, creative sign-offs
- INTEGRATION: Interdepartmental design alignment, technical feasibility
Format as professional production design coordination documentation.`,
                        'summary-report': `Please respond with structured production monitoring specifications for "${taskId}". Generate comprehensive quality assessment documentation including:
- ANALYSIS: Production quality assessment, performance metrics, trend analysis
- TRACKING: Progress monitoring, milestone evaluation, deliverable quality
- REPORTING: Executive summaries, stakeholder updates, performance dashboards
- RECOMMENDATIONS: Process improvements, quality enhancements, strategic adjustments
- OVERSIGHT: System-wide monitoring, cross-agent performance evaluation
Format as professional production monitoring documentation.`,
                        'choreographer': `Please respond with structured movement notation for "${taskId}". Generate detailed choreographic specifications including:
- MOVEMENT: Step-by-step movement description with counts
- STAGING: Stage positions and spatial relationships
- MUSIC: Musical cues and tempo relationships  
- TECHNIQUE: Dance/movement style and difficulty level
- SAFETY: Physical requirements and safety considerations
Format as professional movement notation.`,
                        'voice-coach': `Please respond with structured vocal technique specifications for "${taskId}". Generate comprehensive voice coaching plans including:
- EXERCISES: Specific warm-ups and technique drills
- BREATH: Breathing patterns and support techniques
- RANGE: Vocal range requirements and development
- STYLE: Genre-specific vocal techniques and approaches
- HEALTH: Vocal health and maintenance protocols
Format as structured coaching methodology.`,
                        'method-acting-coach': `Please respond with structured acting technique specifications for "${taskId}". Generate detailed method acting guidance including:
- OBJECTIVES: Character motivations and scene objectives
- SUBSTITUTIONS: Personal substitutions and emotional memory
- PHYSICAL: Physical choices and character embodiment
- PREPARATION: Scene preparation and character research
- EXERCISES: Specific method acting exercises and techniques
Format as professional acting coaching framework.`,
                        'movement-coach': `Please respond with structured movement coaching specifications for "${taskId}". Generate detailed movement training including:
- TECHNIQUE: Specific movement techniques and principles
- EXERCISES: Physical exercises and movement drills
- STAGING: Spatial awareness and stage movement
- CHARACTER: Character-specific movement qualities
- CONDITIONING: Physical conditioning and flexibility
Format as professional movement coaching program.`,
                        'fight-choreographer': `Please respond with structured stage combat specifications for "${taskId}". Generate detailed fight choreography including:
- SEQUENCE: Step-by-step fight sequence with beats
- SAFETY: Safety protocols and risk assessment
- WEAPONS: Weapon handling and stage combat techniques  
- REHEARSAL: Rehearsal process and safety checks
- EFFECTS: Special effects and illusion techniques
Format as professional stage combat notation.`,
                        'dialect-coach': `Please respond with structured dialect coaching specifications for "${taskId}". Generate comprehensive dialect training including:
- PHONETICS: IPA notation and sound changes
- EXERCISES: Articulation drills and practice materials
- RHYTHM: Speech rhythm and intonation patterns
- VOCABULARY: Period/regional vocabulary and expressions
- PRACTICE: Practice sentences and dialogue work
Format as professional dialect coaching methodology.`,
                        'video-director': `Please respond with structured video production specifications for "${taskId}". Generate comprehensive video technical plans including:
- EQUIPMENT: Camera models, lenses, recording devices with specifications
- SETUP: Camera positions, angles, framing with technical measurements
- RECORDING: Video formats, resolution, frame rates, codec settings
- LIGHTING: Video lighting requirements and setup specifications
- WORKFLOW: File management, backup protocols, post-production pipeline
Format as professional video production documentation.`,
                        'props-master': `Please respond with structured prop specifications for "${taskId}". Generate detailed prop management documentation including:
- INVENTORY: Complete prop list with quantities and descriptions
- MATERIALS: Construction materials, tools, and hardware specifications
- CONSTRUCTION: Build instructions, assembly procedures, safety protocols
- STORAGE: Organization systems, transportation, and maintenance protocols
- BUDGET: Cost estimates, sourcing information, vendor contacts
Format as professional prop management documentation.`,
                        'makeup-artist': `Please respond with structured makeup design specifications for "${taskId}". Generate comprehensive makeup technical plans including:
- DESIGN: Character-specific makeup concepts and color palettes
- PRODUCTS: Specific makeup products, brands, and color codes
- APPLICATION: Step-by-step application procedures and techniques
- TIMING: Application time estimates and quick-change procedures
- MAINTENANCE: Touch-up protocols and performance longevity considerations
Format as professional makeup design documentation.`,
                        'wardrobe-supervisor': `Please respond with structured wardrobe management specifications for "${taskId}". Generate comprehensive wardrobe technical documentation including:
- INVENTORY: Complete costume tracking with sizes and condition notes
- MAINTENANCE: Cleaning protocols, repair procedures, storage requirements
- LOGISTICS: Quick-change procedures, backstage organization, crew assignments
- BUDGET: Cost tracking, alteration estimates, replacement planning
- SAFETY: Costume safety checks, emergency procedures, health protocols
Format as professional wardrobe management documentation.`,
                        'stage-manager': `Please respond with structured stage management specifications for "${taskId}". Generate comprehensive stage management documentation including:
- SCHEDULE: Detailed timelines, rehearsal plans, and milestone tracking
- COORDINATION: Communication protocols, cue sequences, crew assignments
- SAFETY: Risk assessment, emergency procedures, safety protocol implementation
- LOGISTICS: Resource allocation, space management, equipment coordination
- DOCUMENTATION: Prompt book organization, report formats, tracking systems
Format as professional stage management documentation.`
                    };
                    
                    const specificPrompt = contextualPrompts[agentId] || 
                        `Create professional ${agentId.replace('-', ' ')} work for "${taskId}". Provide detailed, realistic content.`;
                    
                    // Build enhanced prompts for specialized agents
                    const isMusicAgent = ['music-composer', 'music-director', 'rehearsal-pianist'].includes(agentId);
                    const isVisualDesignAgent = ['set-designer', 'costume-designer', 'lighting-designer', 'projection-designer'].includes(agentId);
                    const isPerformanceCoachAgent = ['choreographer', 'voice-coach', 'method-acting-coach', 'movement-coach', 'fight-choreographer', 'dialect-coach'].includes(agentId);
                    const isTechnicalProductionAgent = ['audio-engineer', 'video-director', 'sound-designer', 'props-master', 'makeup-artist', 'wardrobe-supervisor', 'stage-manager'].includes(agentId);
                    const isAdministrativeMarketingAgent = ['marketing-director', 'publicist', 'social-media-manager', 'audience-development', 'house-manager', 'casting-director', 'assistant-director'].includes(agentId);
                    const isSpecializedLeadershipAgent = ['executive-producer', 'creative-director', 'technical-director', 'production-designer', 'summary-report'].includes(agentId);
                    const isScriptDevelopmentAgent = ['dramaturge', 'script-editor'].includes(agentId);
                    
                    let prompt = `${specificPrompt}

For the musical theater production "Dreams of Tomorrow" - an urban drama about hope and community.

Base task: ${template.title}
Context: ${template.content}`;

                    if (isMusicAgent) {
                        prompt += `

ABC NOTATION REQUIREMENTS:
- Start with header: X:1, T:Title, M:time signature, L:note length, K:key
- Use proper ABC syntax: |: for repeat start, :| for repeat end
- Include chord symbols above melody: "C"C4 "F"F4 "G"G4
- Use appropriate key signatures and time signatures for theater music
- Generate complete, playable musical phrases
- Include lyrics with w: notation if applicable

MUSICAL CONTEXT FOR "DREAMS OF TOMORROW":
- Urban contemporary musical theater style
- Keys that work well for singers (Bb, C, D, Eb, F, G)
- Moderate tempos suitable for storytelling (60-120 BPM)
- Emotional range from introspective ballads to uplifting anthems
- Themes: hope, community, urban life, dreams, transformation

Generate actual ABC notation that can be played and converted to MIDI:`;
                    } else if (isVisualDesignAgent) {
                        prompt += `

VISUAL DESIGN REQUIREMENTS:
- Use structured format with clear sections (DIMENSIONS, MATERIALS, etc.)
- Include specific technical details and measurements
- Provide actionable implementation instructions
- Use professional industry terminology and standards
- Include safety considerations and code compliance

PRODUCTION CONTEXT FOR "DREAMS OF TOMORROW":
- Urban contemporary setting with modern/industrial aesthetic
- Multi-level staging requirements for cityscape scenes
- Color palette: Urban blues, grays, warm accent colors
- Budget: Mid-range professional theater production
- Venue: Standard proscenium theater, 400-600 seats
- Technical capabilities: Standard theater rigging and lighting grid

DESIGN SPECIFICATIONS:
- All measurements in feet and inches
- Use standard theatrical materials and suppliers
- Include approximate costs and sourcing information
- Consider quick scene changes and actor safety
- Design for durability throughout production run

Generate detailed, actionable design specifications:`;
                    } else if (isPerformanceCoachAgent) {
                        prompt += `

PERFORMANCE COACHING REQUIREMENTS:
- Use structured format with clear sections (MOVEMENT, EXERCISES, TECHNIQUE, etc.)
- Include specific technical details and methodologies
- Provide step-by-step instructions and progressions
- Use professional terminology and industry standards
- Include safety considerations and physical requirements

PRODUCTION CONTEXT FOR "DREAMS OF TOMORROW":
- Urban contemporary musical theater with modern themes
- Mixed-skill performer cast requiring accessible techniques
- Production timeline: 8-week rehearsal process
- Performance requirements: 20+ performances over 6 weeks
- Physical demands: Singing, dancing, acting integration
- Safety priority: Stage combat and movement safety protocols

COACHING SPECIFICATIONS:
- All techniques should be learnable within rehearsal timeframe
- Include modification options for different skill levels
- Provide clear practice schedules and progression markers
- Consider performer stamina and vocal health throughout run
- Integrate with music and staging requirements seamlessly

Generate detailed, actionable coaching methodology:`;
                    } else if (isTechnicalProductionAgent) {
                        prompt += `

TECHNICAL PRODUCTION REQUIREMENTS:
- Use structured format with clear sections (EQUIPMENT, SETUP, PROCESSING, etc.)
- Include specific technical details, models, and specifications
- Provide step-by-step procedures and implementation instructions
- Use professional terminology and industry standards
- Include safety considerations and best practices

PRODUCTION CONTEXT FOR "DREAMS OF TOMORROW":
- Professional theater production with 400-600 seat venue
- 8-week rehearsal period, 20+ performance run
- Mixed technical requirements: live music, choreography, set changes
- Budget: Mid-range professional theater production
- Safety priority: Full compliance with theater safety standards
- Quality standards: Broadcast/recording capable technical execution

TECHNICAL SPECIFICATIONS:
- All equipment should meet professional theater standards
- Include backup plans and redundancy for critical systems
- Provide clear documentation for operation and maintenance
- Consider integration with other technical systems
- Include cost estimates and sourcing information where applicable

Generate detailed, actionable technical documentation:`;
                    } else if (isAdministrativeMarketingAgent) {
                        prompt += `

ADMINISTRATIVE/MARKETING REQUIREMENTS:
- Use structured format with clear sections (STRATEGY, METRICS, BUDGET, etc.)
- Include specific KPIs, ROI projections, and measurable outcomes
- Provide detailed timelines, milestones, and deliverable schedules
- Use professional terminology and industry standards
- Include budget breakdowns and resource allocation

PRODUCTION CONTEXT FOR "DREAMS OF TOMORROW":
- Target audience: Urban professionals 25-54, theater enthusiasts
- Marketing budget: $50,000 for 8-week campaign
- Venue capacity: 400-600 seats, 20+ performance run
- Competition: 3 other musicals running concurrently
- Community focus: Local partnerships and educational outreach
- Success metrics: 85% capacity, positive reviews, social engagement

ADMINISTRATIVE SPECIFICATIONS:
- All campaigns should include measurable success criteria
- Provide specific tactics for each strategic objective
- Include contingency plans for underperforming campaigns
- Consider cross-departmental coordination requirements
- Document approval processes and stakeholder sign-offs

Generate detailed, actionable administrative/marketing documentation:`;
                    } else if (isSpecializedLeadershipAgent) {
                        prompt += `

SPECIALIZED LEADERSHIP REQUIREMENTS:
- Use structured format with clear sections (STRATEGY, BUDGET, DECISIONS, etc.)
- Include executive-level decision frameworks and approval criteria
- Provide strategic oversight, quality standards, and risk assessment
- Use professional terminology and industry leadership standards
- Include stakeholder communication and cross-departmental coordination

PRODUCTION CONTEXT FOR "DREAMS OF TOMORROW":
- $2.5M total production budget with investor oversight
- Executive board reporting requirements and ROI expectations
- Multi-departmental coordination across 35+ specialized roles
- Quality standards: Professional theater industry benchmarks
- Timeline: 20-week production cycle from concept to opening
- Risk management: Financial, creative, technical, and operational

LEADERSHIP SPECIFICATIONS:
- All decisions should include strategic rationale and impact assessment
- Provide clear approval criteria and quality benchmarks
- Include risk mitigation strategies and contingency planning
- Consider cross-departmental dependencies and resource allocation
- Document stakeholder communication and reporting requirements

Generate detailed, actionable leadership documentation:`;
                    } else if (isScriptDevelopmentAgent) {
                        prompt += `

SCRIPT DEVELOPMENT REQUIREMENTS:
- Use structured format with clear sections (STRUCTURE, CHARACTER, THEME, etc.)
- Include detailed analysis with specific line/scene references
- Provide professional dramaturgical and editorial standards
- Use industry-standard terminology and formatting guidelines
- Include quality assessment metrics and improvement recommendations

PRODUCTION CONTEXT FOR "DREAMS OF TOMORROW":
- Genre: Contemporary urban musical theater drama
- Target audience: Adult contemporary, socially conscious themes
- Script length: Full-length musical (2 acts, approximately 2.5 hours)
- Character count: 8 principals, 12 ensemble members
- Themes: Hope, community, urban transformation, dreams, resilience
- Style: Realistic dialogue with heightened musical moments

SCRIPT DEVELOPMENT SPECIFICATIONS:
- All analysis should reference specific script elements
- Provide measurable quality metrics and improvement criteria
- Include character consistency tracking across scenes
- Document revision history and editorial decision rationale
- Ensure thematic coherence and dramatic effectiveness

Generate detailed, actionable script development documentation:`;
                    } else {
                        prompt += `

Create comprehensive, professional content that shows deep expertise in your field:`;
                    }
                    
                    console.log(`ü¶ô Calling Ollama for ${agentId}...`);
                    console.log(`üìù Prompt: ${prompt.substring(0, 100)}...`);
                    
                    const startTime = Date.now();
                    const ollamaResult = await window.ollamaConnectionManager.generateContent(agentId, prompt);
                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    
                    console.log(`‚è±Ô∏è ${agentId} Ollama call took ${elapsed}s`);
                    console.log(`üìÑ Result: ${JSON.stringify({
                        model: ollamaResult.model,
                        instance: ollamaResult.instance,
                        contentLength: ollamaResult.content?.length || 0,
                        aiGenerated: ollamaResult.aiGenerated
                    })}`);
                    
                    if (!ollamaResult.aiGenerated) {
                        console.warn(`‚ö†Ô∏è ${agentId} did not get AI-generated content!`);
                    }
                    
                    // Validate and process specialized content for different agent types
                    let processedContent = ollamaResult.content;
                    let musicData = null;
                    let visualDesignData = null;
                    let performanceCoachingData = null;
                    let technicalProductionData = null;
                    let administrativeMarketingData = null;
                    let specializedLeadershipData = null;
                    let scriptDevelopmentData = null;
                    
                    if (isMusicAgent) {
                        musicData = this.validateAndProcessABCNotation(ollamaResult.content, agentId, taskId);
                        if (musicData.isValid) {
                            console.log(`üéµ ${agentId} generated valid ABC notation (${musicData.abcContent.length} chars)`);
                            processedContent = musicData.abcContent;
                        } else {
                            console.warn(`‚ö†Ô∏è ${agentId} generated invalid or no ABC notation: ${musicData.error}`);
                        }
                    } else if (isVisualDesignAgent) {
                        visualDesignData = this.validateAndProcessVisualDesign(ollamaResult.content, agentId, taskId);
                        if (visualDesignData.isValid) {
                            console.log(`üé® ${agentId} generated structured design specs (${visualDesignData.structuredContent.length} chars)`);
                            processedContent = visualDesignData.structuredContent;
                        } else {
                            console.warn(`‚ö†Ô∏è ${agentId} generated unstructured design content: ${visualDesignData.error}`);
                        }
                    } else if (isPerformanceCoachAgent) {
                        performanceCoachingData = this.validateAndProcessPerformanceCoaching(ollamaResult.content, agentId, taskId);
                        if (performanceCoachingData.isValid) {
                            console.log(`üé≠ ${agentId} generated structured coaching methodology (${performanceCoachingData.qualityScore}/100)`);
                            processedContent = performanceCoachingData.structuredContent;
                        } else {
                            console.warn(`‚ö†Ô∏è ${agentId} generated unstructured coaching content: ${performanceCoachingData.error}`);
                        }
                    } else if (isTechnicalProductionAgent) {
                        technicalProductionData = this.validateAndProcessTechnicalProduction(ollamaResult.content, agentId, taskId);
                        if (technicalProductionData.isValid) {
                            console.log(`üîß ${agentId} generated structured technical documentation (${technicalProductionData.qualityScore}/100)`);
                            processedContent = technicalProductionData.structuredContent;
                        } else {
                            console.warn(`‚ö†Ô∏è ${agentId} generated unstructured technical content: ${technicalProductionData.error}`);
                        }
                    } else if (isAdministrativeMarketingAgent) {
                        administrativeMarketingData = this.validateAndProcessAdministrativeMarketing(ollamaResult.content, agentId, taskId);
                        if (administrativeMarketingData.isValid) {
                            console.log(`üìä ${agentId} generated structured administrative/marketing documentation (${administrativeMarketingData.qualityScore}/100)`);
                            processedContent = administrativeMarketingData.structuredContent;
                        } else {
                            console.warn(`‚ö†Ô∏è ${agentId} generated unstructured administrative content: ${administrativeMarketingData.error}`);
                        }
                    } else if (isSpecializedLeadershipAgent) {
                        specializedLeadershipData = this.validateAndProcessSpecializedLeadership(ollamaResult.content, agentId, taskId);
                        if (specializedLeadershipData.isValid) {
                            console.log(`üéØ ${agentId} generated structured leadership documentation (${specializedLeadershipData.qualityScore}/100)`);
                            processedContent = specializedLeadershipData.structuredContent;
                        } else {
                            console.warn(`‚ö†Ô∏è ${agentId} generated unstructured leadership content: ${specializedLeadershipData.error}`);
                        }
                    } else if (isScriptDevelopmentAgent) {
                        scriptDevelopmentData = this.validateAndProcessScriptDevelopment(ollamaResult.content, agentId, taskId);
                        if (scriptDevelopmentData.isValid) {
                            console.log(`üìù ${agentId} generated structured script development documentation (${scriptDevelopmentData.qualityScore}/100)`);
                            processedContent = scriptDevelopmentData.structuredContent;
                        } else {
                            console.warn(`‚ö†Ô∏è ${agentId} generated unstructured script content: ${scriptDevelopmentData.error}`);
                        }
                    }
                    
                    return {
                        ...template,
                        content: processedContent,
                        aiGenerated: true,
                        model: ollamaResult.model,
                        instance: ollamaResult.instance,
                        timestamp: new Date().toLocaleTimeString(),
                        agent: agentId,
                        task: taskId,
                        id: `${taskId}_${agentId}_${Date.now()}`,
                        musicData: musicData, // Include ABC validation results
                        visualDesignData: visualDesignData, // Include visual design validation results
                        performanceCoachingData: performanceCoachingData, // Include performance coaching validation results
                        technicalProductionData: technicalProductionData, // Include technical production validation results
                        administrativeMarketingData: administrativeMarketingData, // Include administrative/marketing validation results
                        specializedLeadershipData: specializedLeadershipData, // Include specialized leadership validation results
                        scriptDevelopmentData: scriptDevelopmentData // Include script development validation results
                    };
                } catch (error) {
                    console.error(`‚ùå CRITICAL: Failed to generate deliverable with AI for ${agentId}:`, error);
                    throw new Error(`AI generation failed for ${agentId} on task ${taskId}: ${error.message}`);
                }
            }

            validateAndProcessABCNotation(content, agentId, taskId) {
                try {
                    // Look for ABC notation patterns in the content
                    const abcPatterns = {
                        header: /X:\s*\d+/,
                        title: /T:\s*.+/,
                        meter: /M:\s*[\d\/]+/,
                        length: /L:\s*[\d\/]+/,
                        key: /K:\s*[A-G][#b]?[m]?/,
                        notes: /[A-Ga-g][',]*[\d\/]*|\|/
                    };
                    
                    // Extract potential ABC notation from content - try multiple approaches
                    let abcContent = '';
                    const lines = content.split('\n');
                    let inABCBlock = false;
                    let abcLines = [];
                    
                    // Approach 1: Look for explicit ABC block starting with X:
                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        
                        // Start of ABC block
                        if (abcPatterns.header.test(trimmedLine)) {
                            inABCBlock = true;
                            abcLines = [trimmedLine];
                            continue;
                        }
                        
                        // Continue collecting ABC lines
                        if (inABCBlock) {
                            // Continue until we find a clear end or enough content
                            if (trimmedLine !== '') {
                                abcLines.push(trimmedLine);
                            }
                            // Stop if we have a substantial ABC block and hit empty line
                            if (trimmedLine === '' && abcLines.length > 4) {
                                break;
                            }
                        }
                    }
                    
                    abcContent = abcLines.join('\n');
                    
                    // Approach 2: If no ABC block found, look for scattered ABC lines
                    if (abcContent.length < 20) {
                        const possibleABCLines = [];
                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            // Look for any line that might be ABC notation
                            if (abcPatterns.header.test(trimmedLine) || 
                                abcPatterns.title.test(trimmedLine) ||
                                abcPatterns.meter.test(trimmedLine) ||
                                abcPatterns.length.test(trimmedLine) ||
                                abcPatterns.key.test(trimmedLine) ||
                                (trimmedLine.length > 3 && abcPatterns.notes.test(trimmedLine))) {
                                possibleABCLines.push(trimmedLine);
                            }
                        }
                        if (possibleABCLines.length > 2) {
                            abcContent = possibleABCLines.join('\n');
                        }
                    }
                    
                    // Validate ABC structure
                    const validation = {
                        hasHeader: abcPatterns.header.test(abcContent),
                        hasTitle: abcPatterns.title.test(abcContent),
                        hasMeter: abcPatterns.meter.test(abcContent),
                        hasLength: abcPatterns.length.test(abcContent),
                        hasKey: abcPatterns.key.test(abcContent),
                        hasNotes: abcPatterns.notes.test(abcContent)
                    };
                    
                    const requiredElements = ['hasHeader', 'hasTitle', 'hasKey'];
                    const isValid = requiredElements.every(element => validation[element]) && abcContent.length > 50;
                    
                    console.log(`üéº ABC Validation for ${agentId}:`, {
                        contentLength: abcContent.length,
                        validation,
                        isValid,
                        extractedABC: abcContent.substring(0, 200) + '...'
                    });
                    
                    if (!isValid) {
                        console.log(`üìù Full content analysis for ${agentId}:`, {
                            originalContentLength: content.length,
                            originalPreview: content.substring(0, 300) + '...',
                            extractedABCPreview: abcContent
                        });
                    }
                    
                    return {
                        isValid,
                        abcContent: abcContent,
                        validation,
                        error: isValid ? null : 'Missing required ABC notation elements',
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                    
                } catch (error) {
                    return {
                        isValid: false,
                        abcContent: '',
                        validation: {},
                        error: `ABC validation failed: ${error.message}`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            validateAndProcessVisualDesign(content, agentId, taskId) {
                try {
                    // Look for structured design specification patterns
                    const designPatterns = {
                        dimensions: /DIMENSIONS?:\s*(.+)/i,
                        materials: /MATERIALS?:\s*(.+)/i,
                        technical: /TECHNICAL:\s*(.+)/i,
                        design: /DESIGN:\s*(.+)/i,
                        budget: /BUDGET:\s*(.+)/i,
                        fixtures: /FIXTURES?:\s*(.+)/i,
                        colors: /COLORS?:\s*(.+)/i,
                        construction: /CONSTRUCTION:\s*(.+)/i
                    };
                    
                    // Extract structured sections
                    const structuredSections = {};
                    let foundSections = 0;
                    
                    for (const [key, pattern] of Object.entries(designPatterns)) {
                        const match = content.match(pattern);
                        if (match) {
                            structuredSections[key] = match[1].trim();
                            foundSections++;
                        }
                    }
                    
                    // Look for measurements and technical specifications
                    const measurements = content.match(/(\d+)\s*['"]?\s*x\s*(\d+)\s*['"]?|\d+\s*ft|\d+\s*inches?/gi) || [];
                    const technicalSpecs = content.match(/\b(LED|halogen|fresnel|ellipsoidal|PAR|moving light|dimmer|cable|rigging|truss)\b/gi) || [];
                    const materials = content.match(/\b(steel|aluminum|wood|fabric|canvas|muslin|scrim|gel|gobo)\b/gi) || [];
                    
                    // Validate structure quality
                    const validation = {
                        hasStructuredSections: foundSections >= 2,
                        hasMeasurements: measurements.length > 0,
                        hasTechnicalSpecs: technicalSpecs.length > 0,
                        hasMaterials: materials.length > 0,
                        sectionsFound: Object.keys(structuredSections),
                        measurementsCount: measurements.length,
                        technicalSpecsCount: technicalSpecs.length,
                        materialsCount: materials.length
                    };
                    
                    const qualityScore = (
                        (validation.hasStructuredSections ? 40 : 0) +
                        (validation.hasMeasurements ? 20 : 0) +
                        (validation.hasTechnicalSpecs ? 20 : 0) +
                        (validation.hasMaterials ? 20 : 0)
                    );
                    
                    const isValid = qualityScore >= 60 && content.length > 200;
                    
                    console.log(`üé® Visual Design Validation for ${agentId}:`, {
                        contentLength: content.length,
                        foundSections,
                        qualityScore,
                        validation,
                        isValid
                    });
                    
                    if (!isValid) {
                        console.log(`üìù Design content analysis for ${agentId}:`, {
                            contentPreview: content.substring(0, 300) + '...',
                            structuredSections,
                            measurements: measurements.slice(0, 5),
                            technicalSpecs: technicalSpecs.slice(0, 5)
                        });
                    }
                    
                    return {
                        isValid,
                        structuredContent: content,
                        structuredSections,
                        validation,
                        qualityScore,
                        error: isValid ? null : `Low quality score: ${qualityScore}/100`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                    
                } catch (error) {
                    return {
                        isValid: false,
                        structuredContent: '',
                        structuredSections: {},
                        validation: {},
                        qualityScore: 0,
                        error: `Design validation failed: ${error.message}`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            validateAndProcessPerformanceCoaching(content, agentId, taskId) {
                try {
                    // Look for structured performance coaching specification patterns
                    const coachingPatterns = {
                        movement: /MOVEMENT:\s*(.+)/i,
                        exercises: /EXERCISES?:\s*(.+)/i,
                        technique: /TECHNIQUE:\s*(.+)/i,
                        staging: /STAGING:\s*(.+)/i,
                        safety: /SAFETY:\s*(.+)/i,
                        objectives: /OBJECTIVES?:\s*(.+)/i,
                        preparation: /PREPARATION:\s*(.+)/i,
                        breath: /BREATH:\s*(.+)/i,
                        range: /RANGE:\s*(.+)/i,
                        style: /STYLE:\s*(.+)/i,
                        health: /HEALTH:\s*(.+)/i,
                        physical: /PHYSICAL:\s*(.+)/i,
                        character: /CHARACTER:\s*(.+)/i,
                        conditioning: /CONDITIONING:\s*(.+)/i,
                        sequence: /SEQUENCE:\s*(.+)/i,
                        weapons: /WEAPONS?:\s*(.+)/i,
                        rehearsal: /REHEARSAL:\s*(.+)/i,
                        effects: /EFFECTS?:\s*(.+)/i,
                        phonetics: /PHONETICS?:\s*(.+)/i,
                        rhythm: /RHYTHM:\s*(.+)/i,
                        vocabulary: /VOCABULARY:\s*(.+)/i,
                        practice: /PRACTICE:\s*(.+)/i,
                        music: /MUSIC:\s*(.+)/i
                    };
                    
                    // Extract structured sections
                    const structuredSections = {};
                    let foundSections = 0;
                    
                    for (const [key, pattern] of Object.entries(coachingPatterns)) {
                        const match = content.match(pattern);
                        if (match) {
                            structuredSections[key] = match[1].trim();
                            foundSections++;
                        }
                    }
                    
                    // Look for technical specifications and methodologies
                    const stepByStepInstructions = content.match(/\b(step \d+|count \d+|beat \d+|bar \d+|\d+\.\s)/gi) || [];
                    const technicalTerms = content.match(/\b(IPA|phoneme|articulation|resonance|diaphragm|legato|staccato|adagio|allegro|pli√©|tendu|relev√©|chass√©|pirouette|arabesque)\b/gi) || [];
                    const safetyConsiderations = content.match(/\b(safety|warm-up|cool-down|injury|prevention|modification|alternative|caution|warning)\b/gi) || [];
                    const progressionMarkers = content.match(/\b(beginner|intermediate|advanced|week \d+|day \d+|level \d+|progression|build-up)\b/gi) || [];
                    
                    // Validate structure quality
                    const validation = {
                        hasStructuredSections: foundSections >= 3,
                        hasStepByStepInstructions: stepByStepInstructions.length > 0,
                        hasTechnicalTerms: technicalTerms.length > 0,
                        hasSafetyConsiderations: safetyConsiderations.length > 0,
                        hasProgressionMarkers: progressionMarkers.length > 0,
                        sectionsFound: Object.keys(structuredSections),
                        instructionCount: stepByStepInstructions.length,
                        technicalTermCount: technicalTerms.length,
                        safetyConsiderationsCount: safetyConsiderations.length,
                        progressionMarkersCount: progressionMarkers.length
                    };
                    
                    const qualityScore = (
                        (validation.hasStructuredSections ? 30 : 0) +
                        (validation.hasStepByStepInstructions ? 25 : 0) +
                        (validation.hasTechnicalTerms ? 20 : 0) +
                        (validation.hasSafetyConsiderations ? 15 : 0) +
                        (validation.hasProgressionMarkers ? 10 : 0)
                    );
                    
                    const isValid = qualityScore >= 70;
                    
                    // Debug logging for failed validations
                    if (!isValid) {
                        console.log(`üìù Performance coaching analysis for ${agentId}:`, {
                            contentPreview: content.substring(0, 300) + '...',
                            structuredSections,
                            instructions: stepByStepInstructions.slice(0, 5),
                            technicalTerms: technicalTerms.slice(0, 5),
                            safetyConsiderations: safetyConsiderations.slice(0, 3)
                        });
                    }
                    
                    return {
                        isValid,
                        structuredContent: content,
                        structuredSections,
                        validation,
                        qualityScore,
                        error: isValid ? null : `Low quality score: ${qualityScore}/100`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                    
                } catch (error) {
                    return {
                        isValid: false,
                        structuredContent: '',
                        structuredSections: {},
                        validation: {},
                        qualityScore: 0,
                        error: `Performance coaching validation failed: ${error.message}`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            validateAndProcessTechnicalProduction(content, agentId, taskId) {
                try {
                    // Look for structured technical production specification patterns
                    const technicalPatterns = {
                        equipment: /EQUIPMENT:\s*(.+)/i,
                        setup: /SETUP:\s*(.+)/i,
                        processing: /PROCESSING:\s*(.+)/i,
                        recording: /RECORDING:\s*(.+)/i,
                        delivery: /DELIVERY:\s*(.+)/i,
                        inventory: /INVENTORY:\s*(.+)/i,
                        materials: /MATERIALS:\s*(.+)/i,
                        construction: /CONSTRUCTION:\s*(.+)/i,
                        storage: /STORAGE:\s*(.+)/i,
                        budget: /BUDGET:\s*(.+)/i,
                        design: /DESIGN:\s*(.+)/i,
                        products: /PRODUCTS:\s*(.+)/i,
                        application: /APPLICATION:\s*(.+)/i,
                        timing: /TIMING:\s*(.+)/i,
                        maintenance: /MAINTENANCE:\s*(.+)/i,
                        logistics: /LOGISTICS:\s*(.+)/i,
                        safety: /SAFETY:\s*(.+)/i,
                        schedule: /SCHEDULE:\s*(.+)/i,
                        coordination: /COORDINATION:\s*(.+)/i,
                        documentation: /DOCUMENTATION:\s*(.+)/i,
                        effects: /EFFECTS:\s*(.+)/i,
                        synthesis: /SYNTHESIS:\s*(.+)/i,
                        implementation: /IMPLEMENTATION:\s*(.+)/i,
                        workflow: /WORKFLOW:\s*(.+)/i
                    };
                    
                    // Extract structured sections
                    const structuredSections = {};
                    let foundSections = 0;
                    
                    for (const [key, pattern] of Object.entries(technicalPatterns)) {
                        const match = content.match(pattern);
                        if (match) {
                            structuredSections[key] = match[1].trim();
                            foundSections++;
                        }
                    }
                    
                    // Look for technical specifications and professional terminology
                    const equipmentSpecs = content.match(/\b(HD|4K|48kHz|24-bit|XLR|TRS|MIDI|DMX|Shure|Sennheiser|Canon|Sony|Yamaha|Allen & Heath|ETC|QLab|Pro Tools)\b/gi) || [];
                    const technicalMeasurements = content.match(/\b(\d+Hz|\d+dB|\d+W|\d+V|\d+A|\d+¬∞K|\d+lm|\d+lux|\d+mm|\d+cm|\d+inch|\d+ft)\b/gi) || [];
                    const safetyConsiderations = content.match(/\b(safety|OSHA|fire marshal|emergency|backup|redundancy|grounding|circuit breaker|fuse|inspection)\b/gi) || [];
                    const professionalTerms = content.match(/\b(signal flow|impedance|gain structure|frequency response|dynamic range|SPL|FOH|monitor|cue|fade|crossfade|dimmer|circuit|patch|protocol)\b/gi) || [];
                    
                    // Validate structure quality
                    const validation = {
                        hasStructuredSections: foundSections >= 3,
                        hasEquipmentSpecs: equipmentSpecs.length > 0,
                        hasTechnicalMeasurements: technicalMeasurements.length > 0,
                        hasSafetyConsiderations: safetyConsiderations.length > 0,
                        hasProfessionalTerms: professionalTerms.length > 0,
                        sectionsFound: Object.keys(structuredSections),
                        equipmentSpecsCount: equipmentSpecs.length,
                        measurementsCount: technicalMeasurements.length,
                        safetyConsiderationsCount: safetyConsiderations.length,
                        professionalTermsCount: professionalTerms.length
                    };
                    
                    const qualityScore = (
                        (validation.hasStructuredSections ? 30 : 0) +
                        (validation.hasEquipmentSpecs ? 25 : 0) +
                        (validation.hasTechnicalMeasurements ? 20 : 0) +
                        (validation.hasSafetyConsiderations ? 15 : 0) +
                        (validation.hasProfessionalTerms ? 10 : 0)
                    );
                    
                    const isValid = qualityScore >= 75;
                    
                    // Debug logging for failed validations
                    if (!isValid) {
                        console.log(`üìù Technical production analysis for ${agentId}:`, {
                            contentPreview: content.substring(0, 300) + '...',
                            structuredSections,
                            equipmentSpecs: equipmentSpecs.slice(0, 5),
                            measurements: technicalMeasurements.slice(0, 5),
                            safetyConsiderations: safetyConsiderations.slice(0, 3)
                        });
                    }
                    
                    return {
                        isValid,
                        structuredContent: content,
                        structuredSections,
                        validation,
                        qualityScore,
                        error: isValid ? null : `Low quality score: ${qualityScore}/100`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                    
                } catch (error) {
                    return {
                        isValid: false,
                        structuredContent: '',
                        structuredSections: {},
                        validation: {},
                        qualityScore: 0,
                        error: `Technical production validation failed: ${error.message}`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            validateAndProcessAdministrativeMarketing(content, agentId, taskId) {
                try {
                    // Look for structured administrative/marketing specification patterns
                    const administrativePatterns = {
                        strategy: /STRATEGY:\s*(.+)/i,
                        channels: /CHANNELS:\s*(.+)/i,
                        metrics: /METRICS:\s*(.+)/i,
                        timeline: /TIMELINE:\s*(.+)/i,
                        budget: /BUDGET:\s*(.+)/i,
                        breakdown: /BREAKDOWN:\s*(.+)/i,
                        audition: /AUDITION:\s*(.+)/i,
                        talent: /TALENT:\s*(.+)/i,
                        contracts: /CONTRACTS:\s*(.+)/i,
                        diversity: /DIVERSITY:\s*(.+)/i,
                        press: /PRESS:\s*(.+)/i,
                        contacts: /CONTACTS:\s*(.+)/i,
                        coverage: /COVERAGE:\s*(.+)/i,
                        events: /EVENTS:\s*(.+)/i,
                        content: /CONTENT:\s*(.+)/i,
                        platforms: /PLATFORMS:\s*(.+)/i,
                        engagement: /ENGAGEMENT:\s*(.+)/i,
                        analytics: /ANALYTICS:\s*(.+)/i,
                        schedule: /SCHEDULE:\s*(.+)/i,
                        demographics: /DEMOGRAPHICS:\s*(.+)/i,
                        outreach: /OUTREACH:\s*(.+)/i,
                        accessibility: /ACCESSIBILITY:\s*(.+)/i,
                        retention: /RETENTION:\s*(.+)/i,
                        operations: /OPERATIONS:\s*(.+)/i,
                        safety: /SAFETY:\s*(.+)/i,
                        logistics: /LOGISTICS:\s*(.+)/i,
                        staffing: /STAFFING:\s*(.+)/i,
                        reports: /REPORTS:\s*(.+)/i,
                        schedules: /SCHEDULES:\s*(.+)/i,
                        communication: /COMMUNICATION:\s*(.+)/i,
                        documentation: /DOCUMENTATION:\s*(.+)/i,
                        coordination: /COORDINATION:\s*(.+)/i
                    };
                    
                    // Extract structured sections
                    const structuredSections = {};
                    let foundSections = 0;
                    
                    for (const [key, pattern] of Object.entries(administrativePatterns)) {
                        const match = content.match(pattern);
                        if (match) {
                            structuredSections[key] = match[1].trim();
                            foundSections++;
                        }
                    }
                    
                    // Look for KPIs, metrics, and professional marketing terminology
                    const kpiMetrics = content.match(/\b(\d+%|\$\d+[KMB]?|ROI|CPA|CPM|CTR|CPC|CAC|LTV|conversion rate|engagement rate|reach|impressions|followers|likes|shares|attendance)\b/gi) || [];
                    const timelineElements = content.match(/\b(week \d+|month \d+|Q[1-4]|phase \d+|milestone|launch date|deadline|deliverable)\b/gi) || [];
                    const budgetElements = content.match(/\b(\$[\d,]+|\d+K|\d+M|cost|expense|allocation|vendor|contract)\b/gi) || [];
                    const professionalTerms = content.match(/\b(demographics|psychographics|persona|segmentation|positioning|branding|campaign|strategy|tactics|channel|platform|KPI|analytics|metrics|outreach|partnership|stakeholder)\b/gi) || [];
                    
                    // Validate structure quality
                    const validation = {
                        hasStructuredSections: foundSections >= 3,
                        hasKPIMetrics: kpiMetrics.length > 0,
                        hasTimelineElements: timelineElements.length > 0,
                        hasBudgetElements: budgetElements.length > 0,
                        hasProfessionalTerms: professionalTerms.length > 0,
                        sectionsFound: Object.keys(structuredSections),
                        kpiMetricsCount: kpiMetrics.length,
                        timelineElementsCount: timelineElements.length,
                        budgetElementsCount: budgetElements.length,
                        professionalTermsCount: professionalTerms.length
                    };
                    
                    const qualityScore = (
                        (validation.hasStructuredSections ? 30 : 0) +
                        (validation.hasKPIMetrics ? 25 : 0) +
                        (validation.hasTimelineElements ? 20 : 0) +
                        (validation.hasBudgetElements ? 15 : 0) +
                        (validation.hasProfessionalTerms ? 10 : 0)
                    );
                    
                    const isValid = qualityScore >= 70;
                    
                    // Debug logging for failed validations
                    if (!isValid) {
                        console.log(`üìù Administrative/marketing analysis for ${agentId}:`, {
                            contentPreview: content.substring(0, 300) + '...',
                            structuredSections,
                            kpiMetrics: kpiMetrics.slice(0, 5),
                            timelineElements: timelineElements.slice(0, 5),
                            budgetElements: budgetElements.slice(0, 5)
                        });
                    }
                    
                    return {
                        isValid,
                        structuredContent: content,
                        structuredSections,
                        validation,
                        qualityScore,
                        error: isValid ? null : `Low quality score: ${qualityScore}/100`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                    
                } catch (error) {
                    return {
                        isValid: false,
                        structuredContent: '',
                        structuredSections: {},
                        validation: {},
                        qualityScore: 0,
                        error: `Administrative/marketing validation failed: ${error.message}`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            validateAndProcessSpecializedLeadership(content, agentId, taskId) {
                try {
                    // Look for structured specialized leadership specification patterns
                    const leadershipPatterns = {
                        strategy: /STRATEGY:\s*(.+)/i,
                        budget: /BUDGET:\s*(.+)/i,
                        decisions: /DECISIONS:\s*(.+)/i,
                        oversight: /OVERSIGHT:\s*(.+)/i,
                        stakeholders: /STAKEHOLDERS:\s*(.+)/i,
                        vision: /VISION:\s*(.+)/i,
                        standards: /STANDARDS:\s*(.+)/i,
                        coordination: /COORDINATION:\s*(.+)/i,
                        development: /DEVELOPMENT:\s*(.+)/i,
                        review: /REVIEW:\s*(.+)/i,
                        specifications: /SPECIFICATIONS:\s*(.+)/i,
                        planning: /PLANNING:\s*(.+)/i,
                        approval: /APPROVAL:\s*(.+)/i,
                        concept: /CONCEPT:\s*(.+)/i,
                        integration: /INTEGRATION:\s*(.+)/i,
                        analysis: /ANALYSIS:\s*(.+)/i,
                        tracking: /TRACKING:\s*(.+)/i,
                        reporting: /REPORTING:\s*(.+)/i,
                        recommendations: /RECOMMENDATIONS:\s*(.+)/i,
                        quality: /QUALITY:\s*(.+)/i,
                        risk: /RISK:\s*(.+)/i,
                        timeline: /TIMELINE:\s*(.+)/i,
                        resources: /RESOURCES:\s*(.+)/i
                    };
                    
                    // Extract structured sections
                    const structuredSections = {};
                    let foundSections = 0;
                    
                    for (const [key, pattern] of Object.entries(leadershipPatterns)) {
                        const match = content.match(pattern);
                        if (match) {
                            structuredSections[key] = match[1].trim();
                            foundSections++;
                        }
                    }
                    
                    // Look for executive-level terminology and decision frameworks
                    const executiveTerms = content.match(/\b(ROI|strategic|executive|board|stakeholder|investor|approval|oversight|governance|compliance|risk assessment|quality standards|resource allocation|strategic planning|leadership|decision framework)\b/gi) || [];
                    const financialMetrics = content.match(/\b(\$[\d,]+[KMB]?|budget|cost|revenue|profit|loss|margin|EBITDA|cash flow|break-even|investment|financing)\b/gi) || [];
                    const timelineElements = content.match(/\b(milestone|deadline|phase|quarter|Q[1-4]|week \d+|month \d+|fiscal year|timeline|schedule|delivery)\b/gi) || [];
                    const qualityFrameworks = content.match(/\b(benchmark|standard|criteria|assessment|evaluation|review|audit|compliance|certification|validation|approval process)\b/gi) || [];
                    
                    // Validate structure quality
                    const validation = {
                        hasStructuredSections: foundSections >= 3,
                        hasExecutiveTerms: executiveTerms.length > 0,
                        hasFinancialMetrics: financialMetrics.length > 0,
                        hasTimelineElements: timelineElements.length > 0,
                        hasQualityFrameworks: qualityFrameworks.length > 0,
                        sectionsFound: Object.keys(structuredSections),
                        executiveTermsCount: executiveTerms.length,
                        financialMetricsCount: financialMetrics.length,
                        timelineElementsCount: timelineElements.length,
                        qualityFrameworksCount: qualityFrameworks.length
                    };
                    
                    const qualityScore = (
                        (validation.hasStructuredSections ? 30 : 0) +
                        (validation.hasExecutiveTerms ? 25 : 0) +
                        (validation.hasFinancialMetrics ? 20 : 0) +
                        (validation.hasTimelineElements ? 15 : 0) +
                        (validation.hasQualityFrameworks ? 10 : 0)
                    );
                    
                    const isValid = qualityScore >= 75;
                    
                    // Debug logging for failed validations
                    if (!isValid) {
                        console.log(`üìù Specialized leadership analysis for ${agentId}:`, {
                            contentPreview: content.substring(0, 300) + '...',
                            structuredSections,
                            executiveTerms: executiveTerms.slice(0, 5),
                            financialMetrics: financialMetrics.slice(0, 5),
                            timelineElements: timelineElements.slice(0, 5)
                        });
                    }
                    
                    return {
                        isValid,
                        structuredContent: content,
                        structuredSections,
                        validation,
                        qualityScore,
                        error: isValid ? null : `Low quality score: ${qualityScore}/100`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                    
                } catch (error) {
                    return {
                        isValid: false,
                        structuredContent: '',
                        structuredSections: {},
                        validation: {},
                        qualityScore: 0,
                        error: `Specialized leadership validation failed: ${error.message}`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            validateAndProcessScriptDevelopment(content, agentId, taskId) {
                try {
                    // Look for structured script development specification patterns
                    const scriptPatterns = {
                        structure: /STRUCTURE:\s*(.+)/i,
                        character: /CHARACTER:\s*(.+)/i,
                        theme: /THEME:\s*(.+)/i,
                        research: /RESEARCH:\s*(.+)/i,
                        revision: /REVISION:\s*(.+)/i,
                        validation: /VALIDATION:\s*(.+)/i,
                        format: /FORMAT:\s*(.+)/i,
                        dialogue: /DIALOGUE:\s*(.+)/i,
                        revisions: /REVISIONS:\s*(.+)/i,
                        standards: /STANDARDS:\s*(.+)/i,
                        analysis: /ANALYSIS:\s*(.+)/i,
                        recommendations: /RECOMMENDATIONS:\s*(.+)/i,
                        quality: /QUALITY:\s*(.+)/i,
                        consistency: /CONSISTENCY:\s*(.+)/i,
                        development: /DEVELOPMENT:\s*(.+)/i,
                        effectiveness: /EFFECTIVENESS:\s*(.+)/i,
                        coherence: /COHERENCE:\s*(.+)/i,
                        accuracy: /ACCURACY:\s*(.+)/i
                    };
                    
                    // Extract structured sections
                    const structuredSections = {};
                    let foundSections = 0;
                    
                    for (const [key, pattern] of Object.entries(scriptPatterns)) {
                        const match = content.match(pattern);
                        if (match) {
                            structuredSections[key] = match[1].trim();
                            foundSections++;
                        }
                    }
                    
                    // Look for script development terminology and references
                    const scriptTerms = content.match(/\b(act|scene|dialogue|character arc|plot|subplot|theme|motif|dramatic structure|three-act|exposition|rising action|climax|falling action|resolution|conflict|protagonist|antagonist|subtext)\b/gi) || [];
                    const editorialTerms = content.match(/\b(revision|draft|edit|proofread|line edit|copy edit|grammar|punctuation|syntax|style guide|consistency|formatting|version control|track changes)\b/gi) || [];
                    const qualityMetrics = content.match(/\b(effectiveness|coherence|clarity|readability|flow|pacing|rhythm|believability|authenticity|dramatic tension|emotional impact)\b/gi) || [];
                    const referenceElements = content.match(/\b(page \d+|line \d+|scene \d+|act [IVX]+|\d+\.\d+|paragraph \d+|chapter \d+)\b/gi) || [];
                    
                    // Validate structure quality
                    const validation = {
                        hasStructuredSections: foundSections >= 3,
                        hasScriptTerms: scriptTerms.length > 0,
                        hasEditorialTerms: editorialTerms.length > 0,
                        hasQualityMetrics: qualityMetrics.length > 0,
                        hasReferenceElements: referenceElements.length > 0,
                        sectionsFound: Object.keys(structuredSections),
                        scriptTermsCount: scriptTerms.length,
                        editorialTermsCount: editorialTerms.length,
                        qualityMetricsCount: qualityMetrics.length,
                        referenceElementsCount: referenceElements.length
                    };
                    
                    const qualityScore = (
                        (validation.hasStructuredSections ? 30 : 0) +
                        (validation.hasScriptTerms ? 25 : 0) +
                        (validation.hasEditorialTerms ? 20 : 0) +
                        (validation.hasQualityMetrics ? 15 : 0) +
                        (validation.hasReferenceElements ? 10 : 0)
                    );
                    
                    const isValid = qualityScore >= 70;
                    
                    // Debug logging for failed validations
                    if (!isValid) {
                        console.log(`üìù Script development analysis for ${agentId}:`, {
                            contentPreview: content.substring(0, 300) + '...',
                            structuredSections,
                            scriptTerms: scriptTerms.slice(0, 5),
                            editorialTerms: editorialTerms.slice(0, 5),
                            qualityMetrics: qualityMetrics.slice(0, 5)
                        });
                    }
                    
                    return {
                        isValid,
                        structuredContent: content,
                        structuredSections,
                        validation,
                        qualityScore,
                        error: isValid ? null : `Low quality score: ${qualityScore}/100`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                    
                } catch (error) {
                    return {
                        isValid: false,
                        structuredContent: '',
                        structuredSections: {},
                        validation: {},
                        qualityScore: 0,
                        error: `Script development validation failed: ${error.message}`,
                        agent: agentId,
                        task: taskId,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            getAgentsForTask(taskId) {
                const taskMappings = {
                    // Pre-Production Planning
                    'concept_development': ['executive-producer', 'creative-director'],
                    'initial_research': ['dramaturge', 'creative-director'],
                    'budget_planning': ['executive-producer', 'technical-director'],
                    'venue_planning': ['executive-producer', 'house-manager'],
                    
                    // Script Development - Phase 1
                    'story_outline': ['ai-playwright', 'dramaturge'],
                    'character_creation': ['ai-playwright', 'creative-director'],
                    'initial_script_draft': ['ai-playwright', 'script-editor'],
                    'dramaturgical_review': ['dramaturge', 'creative-director'],
                    
                    // Musical Composition - Phase 1
                    'thematic_composition': ['music-composer', 'creative-director'],
                    'song_concepts': ['music-composer', 'music-director'],
                    'musical_structure': ['music-composer', 'dramaturge'],
                    'demo_recordings': ['music-composer', 'rehearsal-pianist'],
                    
                    // Design Conceptualization
                    'visual_concept': ['production-designer', 'creative-director'],
                    'set_design_sketches': ['set-designer', 'technical-director'],
                    'costume_concepts': ['costume-designer', 'creative-director'],
                    'lighting_mood_boards': ['lighting-designer', 'creative-director'],
                    
                    // Script Refinement & Character Development
                    'dialogue_polish': ['ai-playwright', 'script-editor'],
                    'character_arcs': ['ai-playwright', 'dramaturge'],
                    'scene_structure': ['ai-playwright', 'creative-director'],
                    'script_revision_1': ['script-editor', 'dramaturge'],
                    
                    // Advanced Musical Development
                    'full_orchestration': ['music-composer', 'music-director'],
                    'vocal_arrangements': ['music-director', 'voice-coach'],
                    'choreography_integration': ['choreographer', 'music-director'],
                    'musical_revision': ['music-composer', 'creative-director'],
                    
                    // Technical Planning & Engineering
                    'technical_specifications': ['technical-director', 'stage-manager'],
                    'safety_protocols': ['technical-director', 'stage-manager'],
                    'equipment_planning': ['technical-director', 'audio-engineer'],
                    'stage_engineering': ['technical-director', 'set-designer'],
                    
                    // Casting & Performance Preparation
                    'casting_process': ['casting-director', 'creative-director'],
                    'audition_coordination': ['casting-director', 'assistant-director'],
                    'role_assignment': ['casting-director', 'creative-director'],
                    'initial_coaching': ['voice-coach', 'method-acting-coach'],
                    
                    // Design Finalization & Production
                    'final_designs': ['set-designer', 'costume-designer'],
                    'construction_management': ['technical-director', 'props-master'],
                    'costume_production': ['costume-designer', 'wardrobe-supervisor'],
                    'prop_creation': ['props-master', 'set-designer'],
                    
                    // Audio & Visual Systems
                    'sound_design': ['sound-designer', 'audio-engineer'],
                    'audio_programming': ['audio-engineer', 'sound-designer'],
                    'lighting_programming': ['lighting-designer', 'technical-director'],
                    'projection_content': ['projection-designer', 'video-director'],
                    
                    // Rehearsal Coordination
                    'rehearsal_scheduling': ['assistant-director', 'stage-manager'],
                    'blocking_sessions': ['assistant-director', 'choreographer'],
                    'music_rehearsals': ['music-director', 'rehearsal-pianist'],
                    'technical_integration': ['stage-manager', 'technical-director'],
                    
                    // Marketing & Audience Development
                    'marketing_strategy': ['marketing-director', 'audience-development'],
                    'promotional_content': ['publicist', 'social-media-manager'],
                    'community_outreach': ['audience-development', 'house-manager'],
                    'press_relations': ['publicist', 'marketing-director'],
                    
                    // Final Production & Performance
                    'dress_rehearsals': ['stage-manager', 'creative-director'],
                    'final_technical': ['technical-director', 'stage-manager'],
                    'performance_execution': ['stage-manager', 'house-manager'],
                    'production_documentation': ['video-director', 'creative-director'],
                    
                    // Legacy tasks for compatibility
                    'script_creation': ['ai-playwright', 'script-editor', 'dramaturge'],
                    'musical_composition': ['music-composer', 'music-director'],
                    'design_development': ['set-designer', 'costume-designer', 'lighting-designer'],
                    'audio_design': ['sound-designer', 'audio-engineer'],
                    'casting': ['casting-director', 'creative-director'],
                    'coaching_preparation': ['voice-coach', 'method-acting-coach'],
                    'blocking_rehearsals': ['stage-manager', 'choreographer'],
                    'musical_rehearsals': ['music-director', 'rehearsal-pianist'],
                    'technical_rehearsals': ['technical-director', 'lighting-designer'],
                    'costume_makeup_integration': ['costume-designer', 'makeup-artist'],
                    'live_performances': ['stage-manager', 'house-manager'],
                    'video_documentation': ['video-director', 'audio-engineer'],
                    'marketing_campaign': ['marketing-director', 'audience-development'],
                    'daily_reporting': ['summary-report'],
                    'milestone_reporting': ['summary-report'],
                    'production_analytics': ['summary-report']
                };
                
                // Get base agents for the task
                const agents = taskMappings[taskId] || ['executive-producer'];
                
                // Summary Report agent monitors all tasks (except its own reporting tasks)
                if (!agents.includes('summary-report') && 
                    !taskId.includes('reporting') && 
                    !taskId.includes('analytics')) {
                    agents.push('summary-report');
                }
                
                return agents;
            }
            
            onAllAgentsReady(status) {
                this.allAgentsReady = true;
                this.eventBus.publish('all-agents-ready', status);
            }
            
            onProductionComplete(status) {
                this.eventBus.publish('production-complete', status);
                
                // Generate final production report
                this.saveFinalProductionReport(status);
            }

            saveFinalProductionReport(status) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `FINAL_PRODUCTION_REPORT_Dreams_of_Tomorrow_${timestamp}.md`;
                
                // Collect all deliverables
                const allDeliverables = [];
                Object.entries(this.taskDeliverables || {}).forEach(([taskId, deliverables]) => {
                    deliverables.forEach(d => {
                        allDeliverables.push({...d, taskId});
                    });
                });
                
                // Group by agent
                const deliverablesByAgent = {};
                allDeliverables.forEach(d => {
                    if (!deliverablesByAgent[d.agent]) {
                        deliverablesByAgent[d.agent] = [];
                    }
                    deliverablesByAgent[d.agent].push(d);
                });
                
                // Group by task
                const deliverablesByTask = {};
                allDeliverables.forEach(d => {
                    if (!deliverablesByTask[d.taskId]) {
                        deliverablesByTask[d.taskId] = [];
                    }
                    deliverablesByTask[d.taskId].push(d);
                });

                const reportContent = `# Final Production Report
# Dreams of Tomorrow - Musical Theater Production

**Production Completed:** ${new Date().toLocaleString()}
**Total Runtime:** ${this.currentProduction ? `Started ${this.currentProduction.startDate}` : 'Unknown'}
**System:** Enhanced Theater Production System with 36 AI Agents

## Executive Summary
This report documents the complete AI-generated theatrical production "Dreams of Tomorrow," created through collaborative work between 36 specialized theater production agents using real Ollama LLM integration.

### Production Statistics
- **Total Agents:** ${status.lifecycle?.totalAgents || 0}
- **Completed Agents:** ${status.lifecycle?.completeAgents?.length || 0}
- **Total Deliverables:** ${allDeliverables.length}
- **AI-Generated Content:** ${allDeliverables.filter(d => d.aiGenerated).length} deliverables
- **Total Characters Generated:** ${allDeliverables.reduce((sum, d) => sum + (d.content?.length || 0), 0).toLocaleString()}

### Models Used
${[...new Set(allDeliverables.map(d => d.model).filter(Boolean))].map(model => `- ${model}`).join('\n')}

## Agent Performance Summary
${Object.entries(deliverablesByAgent).map(([agent, deliverables]) => `
### ${agent.replace('-', ' ').toUpperCase()}
- **Deliverables Created:** ${deliverables.length}
- **Total Content:** ${deliverables.reduce((sum, d) => sum + (d.content?.length || 0), 0).toLocaleString()} characters
- **AI Generated:** ${deliverables.filter(d => d.aiGenerated).length}/${deliverables.length}
- **Tasks Completed:** ${[...new Set(deliverables.map(d => d.taskId))].join(', ')}
`).join('')}

## Task Breakdown
${Object.entries(deliverablesByTask).map(([taskId, deliverables]) => `
### ${taskId.replace('_', ' ').toUpperCase()}
- **Agents Involved:** ${[...new Set(deliverables.map(d => d.agent))].join(', ')}
- **Deliverables:** ${deliverables.length}
- **Total Content:** ${deliverables.reduce((sum, d) => sum + (d.content?.length || 0), 0).toLocaleString()} characters
${deliverables.map(d => `  - ${d.title} (${d.agent})`).join('\n')}
`).join('')}

## Complete Content Archive
${allDeliverables.map((d, i) => `
### ${i + 1}. ${d.title}
**Agent:** ${d.agent} | **Task:** ${d.taskId} | **Type:** ${d.type}  
**AI Model:** ${d.model || 'Unknown'} | **Generated:** ${d.timestamp}  
**Length:** ${d.content?.length || 0} characters

${d.content}

---
`).join('')}

## Technical Details
- **System Architecture:** 36-agent collaborative AI system
- **LLM Integration:** Real Ollama instances with load balancing
- **File Exports:** Individual deliverables, task summaries, phase reports
- **Agent Lifecycle:** State machine with proper transitions
- **Quality Control:** AI-generated content with validation

## Production Notes
"Dreams of Tomorrow" represents a fully AI-generated musical theater production, created through sophisticated multi-agent collaboration. Every aspect from script development to technical planning was generated by specialized AI agents working together.

**Generated by Enhanced Theater Production System**  
**Final Report Timestamp:** ${new Date().toLocaleString()}
`;

                const blob = new Blob([reportContent], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log(`üèÜ Saved final production report: ${filename}`);
                console.log(`üìä Report includes ${allDeliverables.length} deliverables from ${Object.keys(deliverablesByAgent).length} agents`);
            }
            
            getSystemStatus() {
                return {
                    lifecycle: this.lifecycleManager.getSystemStatus(),
                    production: this.currentProduction,
                    running: this.productionRunning
                };
            }
        }

        // ===== APPLICATION CODE =====
        
        let orchestrator = null;
        let statusUpdateInterval = null;
        let phaseUpdateInterval = null;

        // Initialize system
        function initializeSystem() {
            try {
                // Create mock connection manager for simulation
                window.ollamaConnectionManager = {
                    mode: 'OLLAMA',
                    getModeIndicator: () => 'ü¶ô',
                    instances: [
                        'http://localhost:11434',
                        'http://localhost:11435', 
                        'http://localhost:11436',
                        'http://localhost:11437'
                    ],
                    activeInstances: [],
                    currentInstance: 0,
                    initialized: false,
                    
                    async initialize() {
                        if (this.initialized) return;
                        
                        console.log('ü¶ô Checking Ollama instances...');
                        this.activeInstances = [];
                        
                        for (const instance of this.instances) {
                            try {
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 3000);
                                
                                const response = await fetch(`${instance}/api/tags`, {
                                    method: 'GET',
                                    signal: controller.signal
                                });
                                
                                clearTimeout(timeoutId);
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    this.activeInstances.push(instance);
                                    console.log(`‚úÖ Ollama instance active: ${instance} (${data.models?.length || 0} models)`);
                                } else {
                                    console.log(`‚ùå Ollama instance not responding: ${instance}`);
                                }
                            } catch (error) {
                                console.log(`‚ùå Ollama instance unavailable: ${instance} - ${error.message}`);
                            }
                        }
                        
                        if (this.activeInstances.length === 0) {
                            console.error('‚ùå CRITICAL: No Ollama instances found - system cannot run');
                            this.mode = 'FAILED';
                            throw new Error('No Ollama instances available. Start Ollama servers on ports 11434-11437 before running.');
                        } else {
                            console.log(`ü¶ô Found ${this.activeInstances.length} active Ollama instances`);
                        }
                        
                        this.initialized = true;
                    },
                    
                    getNextInstance() {
                        if (this.activeInstances.length === 0) return null;
                        const instance = this.activeInstances[this.currentInstance];
                        this.currentInstance = (this.currentInstance + 1) % this.activeInstances.length;
                        return instance;
                    },
                    
                    async generateContent(agentId, prompt) {
                        // Initialize if not done yet
                        if (!this.initialized) {
                            await this.initialize();
                        }
                        
                        // Check if we have active instances
                        if (this.mode === 'FAILED' || this.activeInstances.length === 0) {
                            console.error(`‚ùå CRITICAL: ${agentId} cannot generate content - no Ollama instances`);
                            throw new Error(`No Ollama instances available for ${agentId}. System requires Ollama to function.`);
                        }
                        
                        const instance = this.getNextInstance();
                        
                        try {
                            console.log(`ü¶ô ${agentId} using Ollama instance: ${instance}`);
                            
                            const requestBody = {
                                model: 'llama3.2:latest',
                                prompt: `You are a professional ${agentId.replace('-', ' ')} working on a theater production called "Dreams of Tomorrow". ${prompt}\n\nProvide a detailed, professional response appropriate for your role:`,
                                stream: false,
                                options: {
                                    temperature: 0.7,
                                    top_p: 0.9,
                                    num_predict: 500
                                }
                            };
                            
                            console.log(`üì° Sending request to ${instance}/api/generate...`);
                            
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 30000);
                            
                            const response = await fetch(`${instance}/api/generate`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(requestBody),
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) {
                                throw new Error(`Ollama request failed: ${response.status} ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            console.log(`‚úÖ ${agentId} completed Ollama generation (${data.response?.length || 0} chars from ${data.model || 'unknown'})`);
                            
                            return {
                                content: data.response || `Professional work completed by ${agentId}`,
                                usage: { total_tokens: data.eval_count || 150 },
                                model: data.model || 'llama3.2',
                                instance: instance,
                                aiGenerated: true
                            };
                            
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è Ollama failed for ${agentId} on ${instance}:`, error.message);
                            
                            // Try to remove this instance from active list if it's consistently failing
                            if (error.message.includes('fetch') || error.message.includes('timeout')) {
                                const index = this.activeInstances.indexOf(instance);
                                if (index > -1) {
                                    this.activeInstances.splice(index, 1);
                                    console.log(`üö´ Removed failing instance: ${instance}`);
                                }
                            }
                            
                            // No fallback - system fails if Ollama fails
                            console.error(`‚ùå CRITICAL: Ollama generation failed for ${agentId}`);
                            throw new Error(`Ollama generation failed for ${agentId}: ${error.message}`);
                        }
                    }
                };

                orchestrator = new EnhancedProductionOrchestrator({
                    maxIterations: 2,
                    qualityThreshold: 0.85,
                    budgetPerTask: 500
                });

                // Initialize Ollama connection manager
                window.ollamaConnectionManager.initialize().then(() => {
                    log('‚úÖ Enhanced Production Orchestrator initialized');
                    log(`ü¶ô Ollama Status: ${window.ollamaConnectionManager.mode} mode`);
                    if (window.ollamaConnectionManager.activeInstances.length > 0) {
                        log(`üì° Active Ollama instances: ${window.ollamaConnectionManager.activeInstances.length}`);
                    }
                });
                log(`üìä Registered ${orchestrator.lifecycleManager.agentStates.size} agents`);
                
                // Enable controls
                document.getElementById('initBtn').disabled = false;
                document.getElementById('statusBtn').disabled = false;
                
                // Start monitoring
                startStatusMonitoring();

            } catch (error) {
                log(`‚ùå Initialization failed: ${error.message}`);
                showError('System initialization failed: ' + error.message);
            }
        }

        // Start production
        async function startProduction() {
            try {
                document.getElementById('startBtn').disabled = true;
                log('üöÄ Starting Enhanced Production...');
                
                updateWorkflowStatus('Starting production...', 'running');

                if (!orchestrator) {
                    initializeSystem();
                }

                const production = {
                    id: 'enhanced-demo-production',
                    title: 'Enhanced Theater Demo',
                    type: 'musical_theater',
                    startDate: new Date()
                };

                await orchestrator.createProduction(production);
                
                document.getElementById('stopBtn').disabled = false;
                showSuccess('Production started successfully!');

            } catch (error) {
                log(`‚ùå Production failed: ${error.message}`);
                showError('Production failed: ' + error.message);
                document.getElementById('startBtn').disabled = false;
            }
        }

        // Initialize agents
        async function initializeAgents() {
            try {
                if (!orchestrator) {
                    log('‚ùå Orchestrator not initialized');
                    return;
                }

                log('üîß Initializing all 36 agents...');
                await orchestrator.initializeAllAgents();
                log('‚úÖ All agents initialized');
                showSuccess('All agents initialized successfully!');

            } catch (error) {
                log(`‚ùå Agent initialization failed: ${error.message}`);
                showError('Agent initialization failed: ' + error.message);
            }
        }

        // Show detailed status
        function showDetailedStatus() {
            try {
                if (!orchestrator) {
                    log('‚ùå Orchestrator not initialized');
                    return;
                }

                const status = orchestrator.getSystemStatus();
                log('üìä DETAILED SYSTEM STATUS:');
                log(`   System State: ${status.lifecycle.systemState}`);
                log(`   Total Agents: ${status.lifecycle.totalAgents}`);
                log(`   Ready: ${status.lifecycle.readyAgents.length}`);
                log(`   Active: ${status.lifecycle.activeAgents.length}`);
                log(`   Complete: ${status.lifecycle.completeAgents.length}`);
                log(`   Error: ${status.lifecycle.errorAgents.length}`);
                log(`   Progress: ${status.lifecycle.progressPercent.toFixed(1)}%`);
                
                if (status.production) {
                    log(`   Production: ${status.production.title}`);
                    log(`   Running: ${status.running ? 'Yes' : 'No'}`);
                }

            } catch (error) {
                log(`‚ùå Status check failed: ${error.message}`);
                showError('Status check failed: ' + error.message);
            }
        }

        // Stop production
        async function stopProduction() {
            try {
                log('üõë Stopping production...');
                
                if (orchestrator) {
                    orchestrator.productionRunning = false;
                    orchestrator.lifecycleManager.cleanup();
                }

                stopStatusMonitoring();
                updateWorkflowStatus('Production stopped', 'stopped');

                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;

                log('‚úÖ Production stopped');
                showSuccess('Production stopped successfully!');

            } catch (error) {
                log(`‚ùå Stop failed: ${error.message}`);
                showError('Stop failed: ' + error.message);
            }
        }

        // Status monitoring
        function startStatusMonitoring() {
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }
            statusUpdateInterval = setInterval(updateStatusDisplay, 1000);
            
            // Start automatic report updates
            startAutomaticReporting();
        }

        function stopStatusMonitoring() {
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
                statusUpdateInterval = null;
            }
            
            // Stop automatic reporting
            stopAutomaticReporting();
        }

        function updateStatusDisplay() {
            if (!orchestrator) return;

            try {
                const status = orchestrator.lifecycleManager.getSystemStatus();
                
                // Update metrics
                document.getElementById('readyCount').textContent = status.readyAgents.length;
                document.getElementById('activeCount').textContent = status.activeAgents.length;
                document.getElementById('completeCount').textContent = status.completeAgents.length;
                document.getElementById('errorCount').textContent = status.errorAgents.length;

                // Update progress bars
                const overallPercent = status.progressPercent;
                const readinessPercent = (status.readyAgents.length / status.totalAgents) * 100;
                
                document.getElementById('overallProgress').style.width = `${overallPercent}%`;
                document.getElementById('overallProgress').textContent = `${overallPercent.toFixed(1)}%`;
                
                document.getElementById('readinessProgress').style.width = `${readinessPercent}%`;
                document.getElementById('readinessProgress').textContent = `${status.readyAgents.length}/${status.totalAgents}`;

                // Update agent grid
                updateAgentGrid(status);

            } catch (error) {
                console.error('Status update error:', error);
            }
        }

        function updateAgentGrid(status) {
            const grid = document.getElementById('agentGrid');
            let html = '';

            for (const [agentId, agentData] of orchestrator.lifecycleManager.agentStates.entries()) {
                const state = agentData.state;
                const priority = agentData.priority;
                const iterations = agentData.iterations;
                
                html += `
                    <div class="agent-card ${state}">
                        <div class="agent-name">${agentId.replace(/-/g, ' ')}</div>
                        <div class="agent-status">${state}</div>
                        <div style="font-size: 0.7em; margin-top: 5px;">
                            Priority: ${priority} | Iter: ${iterations}
                        </div>
                    </div>
                `;
            }

            grid.innerHTML = html;
        }

        function updateWorkflowStatus(message, status = 'running') {
            const workflowInfo = document.getElementById('workflowInfo');
            const indicator = status === 'running' ? 'üü¢' : status === 'stopped' ? 'üî¥' : 'üü†';
            workflowInfo.innerHTML = `<span class="status-indicator ${status}"></span>${message}`;
        }

        // Automatic reporting functions
        let reportUpdateInterval = null;

        function startAutomaticReporting() {
            if (reportUpdateInterval) {
                clearInterval(reportUpdateInterval);
            }
            
            // Update reports every 10 seconds
            reportUpdateInterval = setInterval(updateAllReports, 10000);
            
            // Initial update
            updateAllReports();
        }

        function stopAutomaticReporting() {
            if (reportUpdateInterval) {
                clearInterval(reportUpdateInterval);
                reportUpdateInterval = null;
            }
        }

        function updateAllReports() {
            if (!orchestrator) return;
            
            try {
                updateDailyReport();
                updateMilestoneReport();
                updateActivityHighlights();
                updateDeliverablesDisplay();
            } catch (error) {
                console.error('Report update error:', error);
            }
        }

        function updateDailyReport() {
            const status = orchestrator.getSystemStatus();
            const dailyReport = document.getElementById('dailyReport');
            const timestamp = document.getElementById('dailyReportTimestamp');
            
            // Get recent deliverables from orchestrator
            const recentDeliverables = getRecentDeliverables();
            const deliverablesSummary = recentDeliverables.length > 0 ? 
                recentDeliverables.slice(0, 3).map(d => `‚Ä¢ ${d.title} (${d.agent})`).join('\n') :
                '‚Ä¢ Production initialization in progress';
            
            const reportContent = `
üìä Production: "Dreams of Tomorrow" - Urban Musical Drama
üë• Active Agents: ${status.lifecycle?.activeAgents?.length || 0}
‚úÖ Completed Agents: ${status.lifecycle?.completeAgents?.length || 0}
üìà System Progress: ${(status.lifecycle?.progressPercent || 0).toFixed(1)}%
üéØ Current Phase: ${status.lifecycle?.systemState || 'Initializing'}

üìã Recent Deliverables:
${deliverablesSummary}

üåü Production Progress:
‚Ä¢ Script development: ${getTaskProgress('script_creation')}
‚Ä¢ Musical composition: ${getTaskProgress('musical_composition')}
‚Ä¢ Design development: ${getTaskProgress('design_development')}
‚Ä¢ Technical planning: ${getTaskProgress('technical_planning')}
            `.trim();
            
            dailyReport.textContent = reportContent;
            timestamp.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }

        function updateMilestoneReport() {
            const status = orchestrator.getSystemStatus();
            const milestoneReport = document.getElementById('milestoneReport');
            const timestamp = document.getElementById('milestoneReportTimestamp');
            
            let milestoneContent = '';
            
            if (status.lifecycle?.systemState === 'ALL_READY') {
                milestoneContent = `
üéâ MILESTONE ACHIEVED: All Agents Ready

üìÖ Achievement Date: ${new Date().toLocaleDateString()}
üë• Agents Initialized: ${status.lifecycle?.totalAgents || 0}
‚≠ê Success Rate: 100%
üéØ Impact: Production ready to begin

This milestone demonstrates successful:
‚Ä¢ Agent lifecycle management
‚Ä¢ Coordination system initialization
‚Ä¢ Quality control system activation
                `.trim();
            } else if (status.lifecycle?.systemState === 'PRODUCTION_COMPLETE') {
                milestoneContent = `
üèÜ MILESTONE ACHIEVED: Production Complete

üìÖ Completion Date: ${new Date().toLocaleDateString()}
‚úÖ All Agents: Successfully completed tasks
üìä Final Quality: Excellent
üé≠ Production: Ready for performance
                `.trim();
            } else {
                milestoneContent = `
‚è≥ Working towards next milestone...

Current Progress: ${(status.lifecycle?.progressPercent || 0).toFixed(1)}%
Target: All agents ready and coordinated
Estimated Time: Real-time (silicon speed)
                `.trim();
            }
            
            milestoneReport.textContent = milestoneContent;
            timestamp.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }

        // Helper functions for reporting
        function getRecentDeliverables() {
            if (!orchestrator || !orchestrator.taskDeliverables) return [];
            
            const allDeliverables = [];
            Object.values(orchestrator.taskDeliverables).forEach(taskDeliverables => {
                allDeliverables.push(...taskDeliverables);
            });
            
            // Sort by timestamp (most recent first)
            return allDeliverables.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        }

        function getTaskProgress(taskId) {
            if (!orchestrator || !orchestrator.taskDeliverables) return 'Not started';
            
            const taskDeliverables = orchestrator.taskDeliverables[taskId];
            if (!taskDeliverables || taskDeliverables.length === 0) return 'Not started';
            
            return `${taskDeliverables.length} deliverables completed`;
        }

        function getAllDeliverablesByType() {
            if (!orchestrator || !orchestrator.taskDeliverables) return {};
            
            const deliverablesByType = {};
            Object.values(orchestrator.taskDeliverables).forEach(taskDeliverables => {
                taskDeliverables.forEach(deliverable => {
                    if (!deliverablesByType[deliverable.type]) {
                        deliverablesByType[deliverable.type] = [];
                    }
                    deliverablesByType[deliverable.type].push(deliverable);
                });
            });
            
            return deliverablesByType;
        }

        function updateDeliverablesDisplay() {
            const deliverablesContainer = document.getElementById('deliverablesContainer');
            const recentDeliverables = getRecentDeliverables();
            
            if (recentDeliverables.length === 0) {
                deliverablesContainer.innerHTML = `
                    <div style="text-align: center; padding: 20px; opacity: 0.7;">
                        Start production to see creative deliverables
                    </div>
                `;
                return;
            }
            
            // Show the most recent 10 deliverables
            const displayDeliverables = recentDeliverables.slice(0, 10);
            
            deliverablesContainer.innerHTML = displayDeliverables.map(deliverable => `
                <div class="deliverable-item">
                    <div class="deliverable-header">
                        <span>${deliverable.title}</span>
                        <span class="deliverable-type">${deliverable.type}</span>
                    </div>
                    <div class="deliverable-meta">
                        By ${deliverable.agent} ‚Ä¢ ${deliverable.timestamp} ‚Ä¢ Task: ${deliverable.task}
                    </div>
                    <div class="deliverable-content">
                        ${deliverable.content}
                    </div>
                </div>
            `).join('');
        }

        function updateActivityHighlights() {
            const status = orchestrator.getSystemStatus();
            const highlightsReport = document.getElementById('highlightsReport');
            const timestamp = document.getElementById('highlightsReportTimestamp');
            
            const highlights = [];
            const recentDeliverables = getRecentDeliverables();
            const deliverablesByType = getAllDeliverablesByType();
            
            // Show recent creative work
            if (recentDeliverables.length > 0) {
                const latest = recentDeliverables[0];
                highlights.push(`‚ú® Latest: ${latest.title} by ${latest.agent}`);
            }
            
            // Show deliverable counts by type
            if (deliverablesByType.script?.length > 0) {
                highlights.push(`üìù ${deliverablesByType.script.length} script deliverables created`);
            }
            if (deliverablesByType.music?.length > 0) {
                highlights.push(`üéµ ${deliverablesByType.music.length} musical compositions completed`);
            }
            if (deliverablesByType.design?.length > 0) {
                highlights.push(`üé® ${deliverablesByType.design.length} design elements finalized`);
            }
            
            // System status highlights
            if (status.lifecycle?.activeAgents?.length > 0) {
                highlights.push(`üöÄ ${status.lifecycle.activeAgents.length} agents actively creating`);
            }
            
            if (status.lifecycle?.completeAgents?.length > 0) {
                highlights.push(`‚úÖ ${status.lifecycle.completeAgents.length} agents completed their work`);
            }
            
            // Add total deliverable count
            const totalDeliverables = recentDeliverables.length;
            if (totalDeliverables > 0) {
                highlights.push(`üìã ${totalDeliverables} total production deliverables`);
            }
            
            if (status.lifecycle?.errorAgents?.length === 0) {
                highlights.push('üíé Zero errors - perfect execution');
            }
            
            const highlightContent = highlights.length > 0 ? 
                highlights.map(h => `‚Ä¢ ${h}`).join('\n') : 
                '‚Ä¢ System initialization in progress\n‚Ä¢ Preparing for creative work to begin';
            
            highlightsReport.textContent = highlightContent;
            timestamp.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }

        // Utility functions
        function log(message) {
            const logContent = document.getElementById('logContent');
            const timestamp = new Date().toLocaleTimeString();
            logContent.textContent += `[${timestamp}] ${message}\n`;
            logContent.scrollTop = logContent.scrollHeight;
            console.log(message);
        }

        function showError(message) {
            const container = document.querySelector('.container');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-display';
            errorDiv.textContent = `‚ùå ${message}`;
            container.prepend(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            const container = document.querySelector('.container');
            const successDiv = document.createElement('div');
            successDiv.className = 'success-display';
            successDiv.textContent = `‚úÖ ${message}`;
            container.prepend(successDiv);
            setTimeout(() => successDiv.remove(), 3000);
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            log('üé≠ Enhanced Theater Production System Loaded');
            log('üåê Access via: http://localhost:8000/enhanced-theater-production-full.html');
            log('üìã Start with: python -m http.server 8000');
            
            setTimeout(initializeSystem, 1000);
        });

        // Global error handler
        window.addEventListener('error', (event) => {
            log(`üí• Error: ${event.error?.message || event.message}`);
            showError(event.error?.message || event.message);
        });

        // Expose for debugging
        window.orchestrator = () => orchestrator;
        window.debugLog = log;
    </script>
</body>
</html>