<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Broken Controls</title>
    <style>
        body {
            margin: 0;
            font-family: monospace;
            background: #000;
            color: #0f0;
            padding: 20px;
        }
        .control {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control label {
            width: 150px;
            color: #ff0;
        }
        .control input[type="range"] {
            width: 200px;
        }
        .control span {
            width: 50px;
        }
        .preview {
            width: 400px;
            height: 300px;
            background: #333;
            margin: 20px 0;
            border: 2px solid #555;
        }
        .log {
            white-space: pre-wrap;
            font-size: 12px;
            background: #111;
            padding: 10px;
            border-radius: 5px;
            max-height: 400px;
            overflow-y: auto;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .test-section {
            background: #111;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }
    </style>
</head>
<body>
    <h1>ðŸ”§ Debug Broken Controls</h1>
    <p>Test each problematic control individually to see what's actually happening</p>

    <div class="test-section">
        <h3>Working Controls (for comparison)</h3>
        <div class="control">
            <label>Face Width:</label>
            <input type="range" id="faceWidth" min="0.5" max="2.0" step="0.1" value="1.0">
            <span id="faceWidthValue">1.0</span>
        </div>
        <div class="control">
            <label>Torso Scale:</label>
            <input type="range" id="torsoScale" min="0.5" max="2.0" step="0.1" value="1.0">
            <span id="torsoScaleValue">1.0</span>
        </div>
        <button onclick="testWorkingControls()">Test Working Controls</button>
    </div>

    <div class="test-section">
        <h3>Broken Controls (to debug)</h3>
        <div class="control">
            <label>Arms:</label>
            <input type="range" id="arms" min="0.5" max="2.0" step="0.1" value="1.0">
            <span id="armsValue">1.0</span>
        </div>
        <div class="control">
            <label>Shoulders:</label>
            <input type="range" id="shoulders" min="0.5" max="2.0" step="0.1" value="1.0">
            <span id="shouldersValue">1.0</span>
        </div>
        <div class="control">
            <label>Jawline:</label>
            <input type="range" id="jawline" min="0" max="1" step="0.1" value="0.5">
            <span id="jawlineValue">0.5</span>
        </div>
        <div class="control">
            <label>Muscle:</label>
            <input type="range" id="muscle" min="0" max="1" step="0.1" value="0.5">
            <span id="muscleValue">0.5</span>
        </div>
        <button onclick="testBrokenControls()">Test Broken Controls</button>
    </div>

    <div class="preview" id="preview"></div>
    <div class="log" id="log"></div>

    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- System components -->
    <script src="../js/core/MeshTemplateSystem.js"></script>
    <script src="../js/core/VertexDeformationEngine.js"></script>

    <script>
        const log = document.getElementById('log');
        let meshSystem = null;
        let deformationEngine = null;
        
        function logMessage(message) {
            const timestamp = new Date().toLocaleTimeString();
            log.innerHTML += `[${timestamp}] ${message}\n`;
            log.scrollTop = log.scrollHeight;
            console.log(message);
        }

        // Update value displays
        ['faceWidth', 'torsoScale', 'arms', 'shoulders', 'jawline', 'muscle'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                document.getElementById(id + 'Value').textContent = e.target.value;
            });
        });

        async function initSystems() {
            try {
                logMessage('ðŸ”§ Initializing debug systems...');
                
                meshSystem = new window.MeshTemplateSystem();
                await meshSystem.initialize();
                logMessage('âœ… MeshTemplateSystem ready');
                
                deformationEngine = new window.VertexDeformationEngine();
                logMessage('âœ… VertexDeformationEngine ready');
                
            } catch (error) {
                logMessage(`âŒ System init failed: ${error.message}`);
                logMessage(`Stack: ${error.stack}`);
            }
        }

        async function testWorkingControls() {
            if (!meshSystem || !deformationEngine) {
                logMessage('âŒ Systems not initialized');
                return;
            }

            try {
                logMessage('âœ… Testing WORKING controls (face width + torso)...');
                
                const faceWidthValue = parseFloat(document.getElementById('faceWidth').value);
                const torsoScaleValue = parseFloat(document.getElementById('torsoScale').value);
                
                logMessage(`Control values: faceWidth=${faceWidthValue}, torsoScale=${torsoScaleValue}`);
                
                const characterSpecs = {
                    gender: 'non-binary',
                    ageGroup: 'young',
                    ethnicity: 'european',
                    body: {
                        proportions: {
                            torso: torsoScaleValue
                        }
                    },
                    facial: {
                        faceWidth: faceWidthValue
                    }
                };
                
                logMessage(`Character specs: ${JSON.stringify(characterSpecs, null, 2)}`);
                
                // Generate and deform
                const baseGeometry = await meshSystem.generateCharacterMesh(characterSpecs);
                logMessage('âœ… Base mesh generated');
                
                const deformedGeometry = await deformationEngine.applyCharacterDeformation(
                    baseGeometry.clone(), 
                    characterSpecs
                );
                logMessage('âœ… Deformations applied');
                
                showMesh(deformedGeometry, `âœ… Working: Face ${faceWidthValue}, Torso ${torsoScaleValue}`);
                
                baseGeometry.dispose();
                
            } catch (error) {
                logMessage(`âŒ Working controls test failed: ${error.message}`);
                logMessage(`Stack: ${error.stack}`);
            }
        }

        async function testBrokenControls() {
            if (!meshSystem || !deformationEngine) {
                logMessage('âŒ Systems not initialized');
                return;
            }

            try {
                logMessage('ðŸ”§ Testing BROKEN controls...');
                
                const armsValue = parseFloat(document.getElementById('arms').value);
                const shouldersValue = parseFloat(document.getElementById('shoulders').value);
                const jawlineValue = parseFloat(document.getElementById('jawline').value);
                const muscleValue = parseFloat(document.getElementById('muscle').value);
                
                logMessage(`Control values: arms=${armsValue}, shoulders=${shouldersValue}, jawline=${jawlineValue}, muscle=${muscleValue}`);
                
                const characterSpecs = {
                    gender: 'non-binary',
                    ageGroup: 'young',
                    ethnicity: 'european',
                    body: {
                        proportions: {
                            arms: armsValue,
                            shoulders: shouldersValue
                        },
                        muscle: {
                            definition: muscleValue
                        }
                    },
                    facial: {
                        jawline: jawlineValue
                    }
                };
                
                logMessage(`Character specs: ${JSON.stringify(characterSpecs, null, 2)}`);
                
                // Test step by step
                logMessage('ðŸ” Step 1: Generate base mesh...');
                const baseGeometry = await meshSystem.generateCharacterMesh(characterSpecs);
                logMessage('âœ… Base mesh generated');
                
                logMessage('ðŸ” Step 2: Apply deformations...');
                
                // Log what the deformation engine actually receives
                console.log('ðŸ” Deformation input specs:', characterSpecs);
                
                const deformedGeometry = await deformationEngine.applyCharacterDeformation(
                    baseGeometry.clone(), 
                    characterSpecs
                );
                logMessage('âœ… Deformations applied (check console for details)');
                
                showMesh(deformedGeometry, `ðŸ”§ Broken: Arms ${armsValue}, Shoulders ${shouldersValue}, Jaw ${jawlineValue}, Muscle ${muscleValue}`);
                
                baseGeometry.dispose();
                
            } catch (error) {
                logMessage(`âŒ Broken controls test failed: ${error.message}`);
                logMessage(`Stack: ${error.stack}`);
            }
        }

        function showMesh(geometry, title) {
            const preview = document.getElementById('preview');
            preview.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, 400 / 300, 0.1, 1000);
            camera.position.set(2, 1.6, 3);
            camera.lookAt(0, 1, 0);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            const material = new THREE.MeshLambertMaterial({
                color: 0xffdbac,
                wireframe: false
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(400, 300);
            renderer.setClearColor(0x333333);
            renderer.render(scene, camera);
            
            preview.appendChild(canvas);
            
            // Add title
            const titleDiv = document.createElement('div');
            titleDiv.textContent = title;
            titleDiv.style.color = '#4f4';
            titleDiv.style.textAlign = 'center';
            titleDiv.style.marginTop = '10px';
            preview.appendChild(titleDiv);
            
            // Cleanup
            material.dispose();
            renderer.dispose();
            
            logMessage(`ðŸ“º Displayed: ${title}`);
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            logMessage('ðŸš€ Debug test ready');
            initSystems();
        });
    </script>
</body>
</html>